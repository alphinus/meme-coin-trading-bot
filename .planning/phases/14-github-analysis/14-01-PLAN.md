---
phase: 14-github-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/events.ts
  - shared/types/integration.ts
  - server/src/integrations/github/analyzer.ts
  - server/src/routes/github.ts
autonomous: true

must_haves:
  truths:
    - "analyzeRepo function fetches README, languages, file tree, and repo metadata via read-only Octokit calls"
    - "AI generates a summary, technologies, use cases, and idea title from the gathered repository data"
    - "An idea is automatically created in the Idea Pool with both idea.created and idea.transcription_added events"
    - "POST /api/github/analyze returns the full analysis synchronously (not fire-and-forget)"
    - "No write operations occur against GitHub -- only repos.get, repos.getContent, repos.listLanguages, git.getTree"
  artifacts:
    - path: "server/src/integrations/github/analyzer.ts"
      provides: "Read-only repo analysis with AI summary and auto-idea creation"
      exports: ["analyzeRepo", "fetchRepoData", "RepoAnalysis"]
    - path: "server/src/routes/github.ts"
      provides: "POST /api/github/analyze route"
      contains: "router.post.*analyze"
    - path: "shared/types/events.ts"
      provides: "integration.github_repo_analyzed event type"
      contains: "integration.github_repo_analyzed"
    - path: "shared/types/integration.ts"
      provides: "RepoAnalysis type export"
      contains: "RepoAnalysis"
  key_links:
    - from: "server/src/integrations/github/analyzer.ts"
      to: "server/src/integrations/github/client.ts"
      via: "getOctokit() import"
      pattern: "getOctokit"
    - from: "server/src/integrations/github/analyzer.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse import with code_analysis task type"
      pattern: "generateAiResponse.*code_analysis"
    - from: "server/src/integrations/github/analyzer.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for idea.created + idea.transcription_added + integration.github_repo_analyzed"
      pattern: "appendEvent.*idea\\.created"
    - from: "server/src/routes/github.ts"
      to: "server/src/integrations/github/analyzer.ts"
      via: "analyzeRepo import"
      pattern: "import.*analyzeRepo.*analyzer"
---

<objective>
Create the read-only GitHub repository analyzer backend: a new `analyzer.ts` module that fetches repository data via Octokit (README, languages, file tree, metadata) and passes it through AI analysis to auto-generate an Idea Pool entry, plus the synchronous POST route to expose it.

Purpose: Implements GH-01/GH-02/GH-04 backend -- the core analysis function that both the web UI (Plan 02) and Telegram (Plan 02) will consume.
Output: `analyzer.ts` module with `analyzeRepo` + `fetchRepoData`, analyze route in `github.ts`, updated event/integration types.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-github-analysis/14-RESEARCH.md

@server/src/integrations/github/fork.ts
@server/src/integrations/github/client.ts
@server/src/integrations/github/api.ts
@server/src/routes/github.ts
@server/src/ai/generate.ts
@server/src/routes/ideas.ts
@shared/types/events.ts
@shared/types/integration.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event type and RepoAnalysis type, create analyzer.ts module</name>
  <files>
    shared/types/events.ts
    shared/types/integration.ts
    server/src/integrations/github/analyzer.ts
  </files>
  <action>
1. In `shared/types/events.ts`:
   - Add `"integration.github_repo_analyzed"` to the EventType union (after `integration.github_code_analyzed`)
   - Add `"integration.github_repo_analyzed"` to the EVENT_TYPES const array (after `integration.github_code_analyzed`)

2. In `shared/types/integration.ts`:
   - Add and export a `RepoAnalysis` interface:
     ```typescript
     export interface RepoAnalysis {
       owner: string;
       repo: string;
       description: string;
       stars: number;
       defaultBranch: string;
       readme: string;
       languages: Record<string, number>;
       fileTree: string[];
       aiSummary: string;
       technologies: string[];
       useCases: string[];
       ideaId: string;
     }
     ```

3. Create `server/src/integrations/github/analyzer.ts`:
   - Import `getOctokit` from `./client.js`, `isGitHubConnected` from `./client.js`, `generateAiResponse` from `../../ai/generate.js`, `appendEvent` from `../../events/store.js`, `randomUUID` from `crypto`, `RepoAnalysis` from `shared/types/integration.js`
   - Constants: `MAX_AI_INPUT_CHARS = 8000`, `MAX_FILE_TREE_ENTRIES = 50`
   - Export `fetchRepoData(owner, repo)` function:
     - Use `Promise.allSettled` (NOT `Promise.all`) to fetch in parallel:
       a. `octokit.repos.get({ owner, repo })` -- metadata (description, stars, default_branch)
       b. `octokit.repos.getContent({ owner, repo, path: "README.md" })` -- README
       c. `octokit.repos.listLanguages({ owner, repo })` -- language breakdown
       d. `octokit.git.getTree({ owner, repo, tree_sha: "HEAD", recursive: "1" })` -- file tree
     - Extract each result from allSettled (check `status === "fulfilled"`)
     - Decode README from base64: `Buffer.from(data.content, "base64").toString("utf-8")`
     - Filter file tree: `.filter(item => item.type === "blob").slice(0, MAX_FILE_TREE_ENTRIES).map(item => item.path).filter((p): p is string => !!p)`
     - Return `{ description, stars, defaultBranch, readme, languages, fileTree }`
   - Export `analyzeRepo(owner, repo, userId, teamId, language)` function:
     - Call `fetchRepoData(owner, repo)` to get raw data
     - Generate correlationId via `randomUUID()`
     - Build AI input by combining README, languages, file tree sections separated by `\n\n---\n\n`
     - Cap total input at `MAX_AI_INPUT_CHARS` with `[...truncated]` suffix
     - Call `generateAiResponse({ taskType: "code_analysis", projectId: teamId, language, systemPrompt, userPrompt: codeContext })`
     - System prompt: ask AI to analyze the repo and respond ONLY with JSON `{ "summary": "...", "technologies": ["..."], "useCases": ["..."], "ideaTitle": "..." }`
     - Parse AI response: try to extract JSON via regex `/\{[\s\S]*\}/`, parse with JSON.parse, fallback to raw text as summary
     - Create idea via TWO events (CRITICAL for correct status transition):
       a. `idea.created` with: `title: ideaTitle || "Inspired by: owner/repo"`, `rawInput: analysis.summary`, `teamId`, `source: "import"` (use "import" to avoid schema changes per research), `sourceUrl: "https://github.com/owner/repo"`
       b. `idea.transcription_added` with: `transcription: analysis.summary`, `title: ideaTitle`
     - Emit `integration.github_repo_analyzed` event with: `owner, repo, analysisResult, ideaId, readOnly: true`
     - Return full `RepoAnalysis` object

   Pattern reference: Follow `fetchCodeContext` from `fork.ts` for Octokit calls, follow `routes/ideas.ts` lines 89-127 for dual event emission.
  </action>
  <verify>
    Run `npx tsc --noEmit` from eluma root -- zero errors. Verify `analyzer.ts` exists and exports `analyzeRepo`, `fetchRepoData`. Verify `RepoAnalysis` is exported from `shared/types/integration.ts`. Verify `integration.github_repo_analyzed` appears in `shared/types/events.ts`.
  </verify>
  <done>
    analyzer.ts compiles, exports analyzeRepo/fetchRepoData/RepoAnalysis type. Event type registered. No write operations against GitHub in any code path (only repos.get, repos.getContent, repos.listLanguages, git.getTree).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add POST /api/github/analyze route with validation and GitHub connection check</name>
  <files>
    server/src/routes/github.ts
  </files>
  <action>
1. In `server/src/routes/github.ts`:
   - Add import: `import { analyzeRepo } from "../integrations/github/analyzer.js";`
   - Add a new Zod schema `analyzeUrlSchema`:
     ```typescript
     const analyzeUrlSchema = z.object({
       url: z.string().min(1, "URL is required").regex(/github\.com/, "Must be a GitHub URL"),
       teamId: z.string().uuid("Team ID must be a valid UUID"),
       language: z.enum(["de", "en"]).optional().default("en"),
     });
     ```
   - Add route BEFORE the fork-analyze route (so it doesn't conflict):
     ```typescript
     router.post("/analyze", validate(analyzeUrlSchema), async (req, res) => {
       try {
         const user = req.user!;
         const { url, teamId, language } = req.body;

         // Require GitHub token for API access
         if (!isGitHubConnected()) {
           res.status(422).json({ success: false, error: "GitHub is not connected. Set GITHUB_TOKEN in .env." });
           return;
         }

         // Parse URL
         const parsed = parseGitHubUrl(url);
         if (!parsed) {
           res.status(400).json({ success: false, error: "Invalid GitHub URL. Expected format: https://github.com/owner/repo" });
           return;
         }

         // Run synchronous analysis (2-5 seconds)
         const result = await analyzeRepo(parsed.owner, parsed.repo, user.id, teamId, language);
         res.json({ success: true, data: result });
       } catch (err) {
         console.error("GitHub analyze error:", err);
         const message = err instanceof Error ? err.message : "Analysis failed";
         res.status(500).json({ success: false, error: message });
       }
     });
     ```

   IMPORTANT: This route returns the full result synchronously (200, not 202). Unlike fork-analyze, read-only analysis is fast enough (2-5 seconds) for a synchronous response. The `parseGitHubUrl` function is already imported in github.ts from api.ts.
  </action>
  <verify>
    Run `npx tsc --noEmit` from eluma root -- zero errors. Verify the route is registered by searching for `router.post("/analyze"` in github.ts.
  </verify>
  <done>
    POST /api/github/analyze route exists, validates URL + teamId, checks GitHub connection, calls analyzeRepo synchronously, returns full RepoAnalysis in response. Route returns 422 when GitHub not connected, 400 for invalid URL, 200 with full analysis on success.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `shared/types/events.ts` contains `integration.github_repo_analyzed` in both the union and const array
3. `shared/types/integration.ts` exports `RepoAnalysis` interface
4. `server/src/integrations/github/analyzer.ts` exists with exports: `analyzeRepo`, `fetchRepoData`
5. `server/src/routes/github.ts` has `POST /analyze` route
6. No references to `createFork`, `forkRepository`, or any write operations in `analyzer.ts` (GH-04 compliance)
</verification>

<success_criteria>
Backend analysis pipeline complete: pasting a GitHub URL into the API returns a full RepoAnalysis object with README summary, tech stack, file tree, AI-generated summary, and auto-created idea ID. All GitHub API calls are read-only.
</success_criteria>

<output>
After completion, create `.planning/phases/14-github-analysis/14-01-SUMMARY.md`
</output>
