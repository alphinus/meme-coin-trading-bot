---
phase: 07-telegram-bot-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/telegram.ts
  - shared/types/notification.ts
  - shared/types/events.ts
  - server/src/telegram/types.ts
  - server/src/telegram/bot.ts
  - server/src/telegram/auth.ts
  - server/src/routes/telegram.ts
  - server/src/app.ts
  - server/package.json
autonomous: true
user_setup:
  - service: telegram
    why: "Telegram Bot API access"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Create bot via @BotFather in Telegram -> copy token"
      - name: TELEGRAM_WEBHOOK_SECRET
        source: "Generate a random string (e.g., openssl rand -hex 16) for webhook URL security"

must_haves:
  truths:
    - "grammY bot instance is created and configured with file download support"
    - "Telegram user can be linked to Eluma user via one-time code flow"
    - "Telegram webhook receives updates at Express endpoint registered before JSON body parser"
  artifacts:
    - path: "shared/types/telegram.ts"
      provides: "TelegramLink, TelegramLinkingCode shared types"
      exports: ["TelegramLink", "TelegramLinkingCode"]
    - path: "shared/types/notification.ts"
      provides: "NotificationChannel, NotificationPriority, NotificationPreferenceState types"
      exports: ["NotificationChannel", "NotificationPriority", "NotificationPreferenceState", "DEFAULT_PREFERENCES"]
    - path: "server/src/telegram/bot.ts"
      provides: "Bot instance with BotContext type flavor"
      exports: ["bot", "BotContext"]
    - path: "server/src/telegram/auth.ts"
      provides: "Telegram-Eluma user linking and resolution"
      exports: ["linkTelegramUser", "getTelegramLink", "resolveElumaUser", "generateLinkingCode", "consumeLinkingCode"]
    - path: "server/src/routes/telegram.ts"
      provides: "Express webhook route for Telegram updates"
  key_links:
    - from: "server/src/routes/telegram.ts"
      to: "server/src/telegram/bot.ts"
      via: "webhookCallback(bot, 'express')"
      pattern: "webhookCallback"
    - from: "server/src/telegram/auth.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for telegram.user_linked events"
      pattern: "appendEvent.*telegram\\.user_linked"
    - from: "server/src/app.ts"
      to: "server/src/routes/telegram.ts"
      via: "app.use BEFORE express.json()"
      pattern: "telegramRouter.*express\\.json"
---

<objective>
Install grammY and dependencies, create the Telegram bot instance with typed context, implement Telegram-to-Eluma user linking via one-time codes, create the webhook Express route, and register it in app.ts BEFORE the JSON body parser. Also create shared types for both Telegram and notification domains.

Purpose: Establishes the bot infrastructure that all subsequent Telegram plans build on, plus the shared types needed by the parallel notification plan.
Output: Working bot instance receiving Telegram updates, user linking flow, shared type definitions.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-telegram-bot-notifications/07-RESEARCH.md

@eluma/server/src/app.ts
@eluma/server/src/events/store.ts
@eluma/server/src/auth/users.ts
@eluma/shared/types/events.ts
@eluma/shared/types/models.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install grammY ecosystem and create shared types for Telegram and notifications</name>
  <files>
    server/package.json
    shared/types/telegram.ts
    shared/types/notification.ts
    shared/types/events.ts
  </files>
  <action>
    1. Install dependencies in /eluma/server:
       npm install grammy @grammyjs/files @grammyjs/menu @grammyjs/conversations @grammyjs/i18n nodemailer
       npm install -D @types/nodemailer

    2. Create shared/types/telegram.ts with:
       - TelegramLink interface: { telegramUserId: number, elumaUserId: string, telegramChatId: number, linkedAt: string }
       - TelegramLinkingCode interface: { code: string, elumaUserId: string, createdAt: string, expiresAt: string }

    3. Create shared/types/notification.ts with:
       - NotificationChannel type: "web" | "telegram" | "email"
       - NotificationPriority type: "low" | "medium" | "high" | "critical"
       - NotificationPreference interface: { userId: string, channel: NotificationChannel, priority: NotificationPriority, enabled: boolean }
       - NotificationPreferenceState interface: { userId: string, preferences: Record<NotificationChannel, Record<NotificationPriority, boolean>>, telegramChatId?: number, emailAddress?: string }
       - NotificationEvent interface: { id: string, userId: string, type: string, priority: NotificationPriority, title: string, body: string, projectId?: string, timestamp: string, read: boolean }
       - DEFAULT_PREFERENCES constant: web=all enabled, telegram=high+critical only, email=critical only

    4. Add new event types to shared/types/events.ts:
       - "telegram.user_linked" | "telegram.user_unlinked"
       - "notification.preference_updated" | "notification.created" | "notification.read"
       Add these to both the EventType union and the EVENT_TYPES const array.
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit --project shared/tsconfig.json</verify>
  <done>grammY and nodemailer installed, shared types compile, 5 new event types added to EventType union</done>
</task>

<task type="auto">
  <name>Task 2: Create bot instance, auth linking module, and webhook Express route</name>
  <files>
    server/src/telegram/types.ts
    server/src/telegram/bot.ts
    server/src/telegram/auth.ts
    server/src/routes/telegram.ts
    server/src/app.ts
  </files>
  <action>
    1. Create server/src/telegram/types.ts:
       - Import and re-export Context from grammy, FileFlavor from @grammyjs/files, MenuFlavor from @grammyjs/menu, I18nFlavor from @grammyjs/i18n
       - Define SessionData interface with optional fields: pendingWorkflowInput (projectId, stepId, fieldKey), currentProjectId (string)
       - Define BotContext type combining all flavors: FileFlavor<Context> & MenuFlavor & I18nFlavor & { session: SessionData }

    2. Create server/src/telegram/bot.ts:
       - Import Bot, session from grammy, hydrateFiles from @grammyjs/files
       - Import BotContext, SessionData from ./types.js
       - Create bot instance: new Bot<BotContext>(process.env.TELEGRAM_BOT_TOKEN || "")
       - Configure hydrateFiles: bot.api.config.use(hydrateFiles(bot.token))
       - Install session middleware with initial(): SessionData returning empty object
       - Export bot and a setupBot() async function that will be called after all handlers are registered
       - setupBot should: if TELEGRAM_WEBHOOK_URL env var is set, call bot.api.setWebhook(TELEGRAM_WEBHOOK_URL + "/api/telegram/webhook/" + (TELEGRAM_WEBHOOK_SECRET || "secret")); otherwise call bot.start() for dev polling mode
       - Guard bot creation: if TELEGRAM_BOT_TOKEN is empty string, export a null bot and skip setup (graceful no-op when token not configured)

    3. Create server/src/telegram/auth.ts:
       - Import appendEvent, readEvents from events/store.js and loadUser, listUsers from auth/users.js
       - Import getTeamForUser helper: reads team events, finds teams where user is a member (same pattern as existing reducers)
       - getTelegramLink(telegramUserId: number): reads "telegram" aggregate events, finds telegram.user_linked event matching userId, returns TelegramLink or null
       - linkTelegramUser(telegramUserId: number, elumaUserId: string, chatId: number): appends telegram.user_linked event
       - resolveElumaUser(telegramUserId: number): calls getTelegramLink, then loadUser, returns User or null
       - generateLinkingCode(elumaUserId: string): creates 6-digit random numeric code, appends event with 10-minute expiry, returns code string
       - consumeLinkingCode(code: string): reads events to find matching unexpired code, returns elumaUserId or null
       - getTeamForUser(userId: string): reads team events, finds first team where user is member, returns TeamState or null

    4. Create server/src/routes/telegram.ts:
       - Import Router from express, webhookCallback from grammy, bot from telegram/bot.js
       - Create router with single POST route: /webhook/:secret
       - Route handler: validate req.params.secret matches TELEGRAM_WEBHOOK_SECRET env var (or "secret" default), if not return 401
       - If valid, delegate to webhookCallback(bot, "express")
       - If bot is null (no token), return 200 with message "Bot not configured"

    5. Modify server/src/app.ts:
       - Import telegramRouter from routes/telegram.js
       - CRITICAL: Register telegramRouter BEFORE express.json() middleware: app.use("/api/telegram", telegramRouter)
       - This must go between the compression() and express.json() lines
       - Import and call setupBot() in an async IIFE at the bottom of the file (or after app creation), with try/catch logging errors
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit</verify>
  <done>Bot instance created with typed context, auth linking reads/writes events, webhook route registered before JSON parser in app.ts, polling fallback works when no webhook URL configured</done>
</task>

</tasks>

<verification>
- `cd /Users/developer/eluma && npx tsc --noEmit` compiles without errors
- `grep -n "telegramRouter" server/src/app.ts` shows registration BEFORE express.json()
- `grep "telegram.user_linked" shared/types/events.ts` shows new event type registered
- `grep "grammy" server/package.json` confirms grammY installed
</verification>

<success_criteria>
- grammY ^1.39 and all plugins installed in server/package.json
- Bot instance created with BotContext type combining File, Menu, I18n flavors
- Telegram-Eluma user linking via 6-digit code with 10-minute expiry
- Webhook route validates secret and delegates to grammY
- Webhook route registered BEFORE express.json() in app.ts
- Shared types for telegram and notification domains compile cleanly
- 5 new event types added to EventType union
</success_criteria>

<output>
After completion, create `.planning/phases/07-telegram-bot-notifications/07-01-SUMMARY.md`
</output>
