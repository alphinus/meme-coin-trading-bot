---
phase: 07-telegram-bot-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/notifications/types.ts
  - server/src/notifications/preferences.ts
  - server/src/notifications/channels/web.ts
  - server/src/notifications/channels/telegram.ts
  - server/src/notifications/channels/email.ts
  - server/src/notifications/dispatcher.ts
  - server/src/routes/notifications.ts
autonomous: true

must_haves:
  truths:
    - "Notification preferences are event-sourced with sensible defaults (web=all, telegram=high+critical, email=critical)"
    - "Dispatcher routes notifications to enabled channels based on user preferences"
    - "Email channel gracefully degrades when SMTP is not configured"
    - "User can read and update notification preferences via REST API"
  artifacts:
    - path: "server/src/notifications/preferences.ts"
      provides: "Event-sourced notification preference aggregate"
      exports: ["getPreferencesForUser", "updatePreference"]
    - path: "server/src/notifications/dispatcher.ts"
      provides: "Central notification dispatcher routing to channels"
      exports: ["dispatchNotification"]
    - path: "server/src/notifications/channels/web.ts"
      provides: "Web notification channel via event store"
      exports: ["sendWebNotification"]
    - path: "server/src/notifications/channels/telegram.ts"
      provides: "Telegram notification channel via bot API"
      exports: ["sendTelegramNotification"]
    - path: "server/src/notifications/channels/email.ts"
      provides: "Email notification channel via nodemailer"
      exports: ["sendEmailNotification"]
    - path: "server/src/routes/notifications.ts"
      provides: "Notification preferences and history API"
  key_links:
    - from: "server/src/notifications/dispatcher.ts"
      to: "server/src/notifications/preferences.ts"
      via: "getPreferencesForUser to check enabled channels"
      pattern: "getPreferencesForUser"
    - from: "server/src/notifications/dispatcher.ts"
      to: "server/src/notifications/channels/"
      via: "calls sendWebNotification, sendTelegramNotification, sendEmailNotification"
      pattern: "send(Web|Telegram|Email)Notification"
    - from: "server/src/notifications/preferences.ts"
      to: "server/src/events/store.ts"
      via: "readEvents + appendEvent for notification preferences"
      pattern: "readEvents.*notification"
---

<objective>
Build the multi-channel notification system: event-sourced preference aggregate with per-user/per-channel/per-priority settings, three channel dispatchers (web via event store, Telegram via bot API, email via nodemailer), a central dispatcher that routes based on preferences, and REST API for preference management.

Purpose: Enables NOTF-01 requirement -- fully configurable notifications per user, per channel, per priority level. Runs in parallel with Plan 01 (no shared files).
Output: Complete notification subsystem ready for wiring to domain events in Plan 05.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-telegram-bot-notifications/07-RESEARCH.md

@eluma/server/src/events/store.ts
@eluma/shared/types/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build notification preference aggregate and channel dispatchers</name>
  <files>
    server/src/notifications/types.ts
    server/src/notifications/preferences.ts
    server/src/notifications/channels/web.ts
    server/src/notifications/channels/telegram.ts
    server/src/notifications/channels/email.ts
  </files>
  <action>
    1. Create server/src/notifications/types.ts:
       - Re-export NotificationChannel, NotificationPriority, NotificationPreferenceState, NotificationEvent, DEFAULT_PREFERENCES from shared/types/notification.js
       - Add server-only types: DispatchPayload { userId: string, type: string, priority: NotificationPriority, title: string, body: string, projectId?: string }

    2. Create server/src/notifications/preferences.ts:
       - Import readEvents, appendEvent from events/store.js
       - Import DEFAULT_PREFERENCES from shared/types/notification.js
       - getPreferencesForUser(userId: string): reads "notification" aggregate events filtered by aggregateId=userId, reduces notification.preference_updated events into a NotificationPreferenceState. Returns DEFAULT_PREFERENCES merged state if no events exist.
       - updatePreference(userId: string, channel: NotificationChannel, priority: NotificationPriority, enabled: boolean): appends notification.preference_updated event with data { channel, priority, enabled }
       - setTelegramChatId(userId: string, chatId: number): appends notification.preference_updated event with data { telegramChatId: chatId }
       - setEmailAddress(userId: string, email: string): appends notification.preference_updated event with data { emailAddress: email }

    3. Create server/src/notifications/channels/web.ts:
       - Import appendEvent from events/store.js
       - sendWebNotification(payload: DispatchPayload): appends a notification.created event with aggregateType "notification", aggregateId = randomUUID, data includes all payload fields plus read: false
       - getUnreadNotifications(userId: string): reads "notification" aggregate events, filters notification.created where data.userId matches and data.read is false, returns NotificationEvent[]
       - markNotificationRead(notificationId: string, userId: string): appends notification.read event

    4. Create server/src/notifications/channels/telegram.ts:
       - Lazy import of bot from telegram/bot.js (to avoid circular dependency -- use dynamic import)
       - Import getTelegramLink from telegram/auth.js
       - sendTelegramNotification(payload: DispatchPayload): looks up TelegramLink for userId, if linked, sends message via bot.api.sendMessage(chatId, formatNotification(payload), { parse_mode: "Markdown" })
       - formatNotification: builds Markdown string with bold title, body, and optional project link
       - If bot is null or user not linked, log warning and skip silently

    5. Create server/src/notifications/channels/email.ts:
       - Import nodemailer, create transporter with SMTP config from env vars (SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS)
       - sendEmailNotification(payload: DispatchPayload, emailAddress: string): sends email via transporter.sendMail with HTML body
       - If SMTP_HOST is not set, export a no-op function that logs "Email notifications disabled (no SMTP_HOST)" once and returns
       - formatEmailBody: creates minimal HTML email with title, body, timestamp
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit</verify>
  <done>Preference aggregate reads/writes events with DEFAULT_PREFERENCES fallback, all 3 channel dispatchers created with graceful degradation for unconfigured services</done>
</task>

<task type="auto">
  <name>Task 2: Build central dispatcher and notification REST API routes</name>
  <files>
    server/src/notifications/dispatcher.ts
    server/src/routes/notifications.ts
  </files>
  <action>
    1. Create server/src/notifications/dispatcher.ts:
       - Import getPreferencesForUser from ./preferences.js
       - Import sendWebNotification from ./channels/web.js
       - Import sendTelegramNotification from ./channels/telegram.js
       - Import sendEmailNotification from ./channels/email.js
       - dispatchNotification(payload: DispatchPayload): async function that:
         a. Gets user preferences via getPreferencesForUser(payload.userId)
         b. For each channel (web, telegram, email): checks if preferences[channel][payload.priority] is enabled
         c. If web enabled: await sendWebNotification(payload)
         d. If telegram enabled: await sendTelegramNotification(payload)
         e. If email enabled: get emailAddress from preferences, if exists await sendEmailNotification(payload, emailAddress)
         f. All channel sends wrapped in try/catch -- one channel failing does not block others
         g. Returns { dispatched: string[] } listing which channels received the notification

    2. Create server/src/routes/notifications.ts:
       - GET / : getPreferencesForUser(req.session.userId) -> return preferences state
       - PUT /preferences : body { channel, priority, enabled } -> updatePreference -> return updated preferences
       - GET /unread : getUnreadNotifications(req.session.userId) -> return NotificationEvent[]
       - POST /:id/read : markNotificationRead(id, userId) -> return { success: true }
       - All routes use Zod validation for request bodies
       - All routes require auth (will be registered with requireAuth in Plan 05)
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit</verify>
  <done>Central dispatcher evaluates preferences per channel per priority and routes to enabled channels, REST API exposes preference CRUD and notification history</done>
</task>

</tasks>

<verification>
- `cd /Users/developer/eluma && npx tsc --noEmit` compiles without errors
- `grep -r "dispatchNotification" server/src/notifications/` confirms dispatcher exists
- `grep -r "sendWebNotification\|sendTelegramNotification\|sendEmailNotification" server/src/notifications/` confirms all 3 channels
- `grep "DEFAULT_PREFERENCES" server/src/notifications/preferences.ts` confirms fallback defaults
</verification>

<success_criteria>
- Event-sourced preference aggregate with DEFAULT_PREFERENCES fallback
- 3 channel dispatchers: web (event store), telegram (bot API), email (nodemailer)
- Email gracefully disabled when SMTP_HOST not set
- Telegram gracefully skipped when bot not configured or user not linked
- Central dispatcher checks preferences before routing to each channel
- REST API for preference CRUD and unread notification listing
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-telegram-bot-notifications/07-02-SUMMARY.md`
</output>
