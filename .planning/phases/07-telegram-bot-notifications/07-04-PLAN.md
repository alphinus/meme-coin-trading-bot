---
phase: 07-telegram-bot-notifications
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - server/src/telegram/menus/workflow-menu.ts
  - server/src/telegram/handlers/voice.ts
  - server/src/telegram/handlers/text.ts
  - server/src/telegram/handlers/callback.ts
autonomous: true

must_haves:
  truths:
    - "User can interact with GSD workflow steps from Telegram via buttons and text replies"
    - "User can send a voice message in Telegram and receive transcription with routing suggestions"
    - "Voice transcription uses fire-and-forget pattern to avoid 10-second webhook timeout"
    - "Free text messages are routed to pending workflow text_input steps"
  artifacts:
    - path: "server/src/telegram/menus/workflow-menu.ts"
      provides: "GSD workflow step rendering as Telegram menus"
      exports: ["workflowMenu"]
    - path: "server/src/telegram/handlers/voice.ts"
      provides: "Voice message download, transcription, and routing"
      exports: ["handleVoiceMessage"]
    - path: "server/src/telegram/handlers/text.ts"
      provides: "Free text handler for workflow text_input steps"
      exports: ["handleTextMessage"]
    - path: "server/src/telegram/handlers/callback.ts"
      provides: "Callback query handler for workflow step completions"
      exports: ["handleWorkflowCallback"]
  key_links:
    - from: "server/src/telegram/handlers/voice.ts"
      to: "server/src/voice/transcribe.ts"
      via: "transcribeAudio(buffer, language)"
      pattern: "transcribeAudio"
    - from: "server/src/telegram/handlers/voice.ts"
      to: "server/src/voice/router-analysis.ts"
      via: "analyzeVoiceRouting(text, teamId, language)"
      pattern: "analyzeVoiceRouting"
    - from: "server/src/telegram/menus/workflow-menu.ts"
      to: "server/src/workflow/engine.ts"
      via: "getWorkflowState + completeWorkflowStep"
      pattern: "getWorkflowState|completeWorkflowStep"
    - from: "server/src/telegram/handlers/text.ts"
      to: "server/src/workflow/engine.ts"
      via: "completeWorkflowStep for pending text inputs"
      pattern: "completeWorkflowStep"
---

<objective>
Build GSD workflow interaction via Telegram (rendering step types as buttons/text prompts), voice message handling (download, transcribe, route), and free text routing for workflow text_input steps.

Purpose: Satisfies TELE-01 (GSD interactions), TELE-03 (voice message transcription + routing), TELE-04 (AI recognizes project from voice or guides via buttons), and TELE-06 (offline messages processed on arrival -- Telegram handles queuing natively).
Output: Users can complete GSD workflow steps and send voice messages entirely from Telegram.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-telegram-bot-notifications/07-RESEARCH.md
@.planning/phases/07-telegram-bot-notifications/07-01-SUMMARY.md

@eluma/server/src/telegram/bot.ts
@eluma/server/src/telegram/auth.ts
@eluma/server/src/telegram/types.ts
@eluma/server/src/voice/transcribe.ts
@eluma/server/src/voice/router-analysis.ts
@eluma/server/src/workflow/engine.ts
@eluma/server/src/workflow/definitions.ts
@eluma/shared/types/workflow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build workflow menu rendering GSD steps as Telegram interactions</name>
  <files>
    server/src/telegram/menus/workflow-menu.ts
    server/src/telegram/handlers/callback.ts
  </files>
  <action>
    1. Create server/src/telegram/menus/workflow-menu.ts:
       - Import Menu, InlineKeyboard from grammy, BotContext from ../types.js
       - Import getWorkflowState, completeWorkflowStep from workflow/engine.js
       - Import getStepsForPhase, getStepDefinition from workflow/definitions.js
       - Import getProjectById from events/reducers/project.js
       - Import resolveElumaUser from ../auth.js

       workflowMenu = new Menu<BotContext>("workflow").dynamic():
       - Read session.currentProjectId, load project + workflow state
       - Get current step definition from state.currentStepId
       - Render based on step type:

         button_choice:
         - For each option in stepDef.options: text button with option label
         - Callback: complete step with option value, then re-render next step
         - Use short callback data: "wf:{stepId_short}:{optionIdx}"

         text_input:
         - Show info text: step title + description
         - Show "Type your answer below" instruction
         - Set session.pendingWorkflowInput = { projectId, stepId, fieldKey }
         - No buttons needed (user types free text -- handled by text handler)

         info_display:
         - Show step title + description text
         - Show single "Continue" button that completes the step with value "continue"

         ai_prompt:
         - Show step question text
         - Set session.pendingWorkflowInput for the AI prompt response
         - Show "Type your response below" instruction

         auto_advance:
         - Complete step automatically, reply with "Processing..." then render next step

       - After completing a step, check if phase advanced. If so, reply with congratulatory message.
       - If workflow is complete (no more steps), reply with completion message.

       Export workflowMenu.

    2. Create server/src/telegram/handlers/callback.ts:
       - Import BotContext from ../types.js
       - Import completeWorkflowStep from workflow/engine.js
       - Import getWorkflowState from workflow/engine.js

       handleWorkflowCallback(ctx: BotContext): handles callback queries with "wf:" prefix
       - Parse callback data: "wf:{stepId}:{value}"
       - Resolve user, complete workflow step with parsed values
       - Answer callback query
       - Edit message to show step result + render next step
       - If step completion fails, answer callback with error text

       Register: bot.callbackQuery(/^wf:/, handleWorkflowCallback)

       Export handleWorkflowCallback.
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit</verify>
  <done>Workflow steps render as Telegram buttons for choices, text prompts for input, and auto-advance for automated steps. Step completions call existing engine directly.</done>
</task>

<task type="auto">
  <name>Task 2: Build voice message handler and free text handler</name>
  <files>
    server/src/telegram/handlers/voice.ts
    server/src/telegram/handlers/text.ts
  </files>
  <action>
    1. Create server/src/telegram/handlers/voice.ts:
       - Import BotContext from ../types.js
       - Import resolveElumaUser, getTeamForUser from ../auth.js
       - Import transcribeAudio from voice/transcribe.js
       - Import analyzeVoiceRouting from voice/router-analysis.js
       - Import InlineKeyboard from grammy
       - Import bot from ../bot.js (for follow-up messages)

       handleVoiceMessage(ctx: BotContext): async function
       a. Resolve Eluma user. If not linked, reply with link instructions and return.
       b. Reply immediately with "Transcribing your voice message..." (fire-and-forget acknowledgment)
       c. Save chatId and processingMsg.message_id for later editing
       d. Spawn background async task (do NOT await in webhook handler):

          Background task:
          - Download voice file: const file = await ctx.getFile(); construct URL from file.file_path + bot token; fetch as Buffer
          - Call transcribeAudio(buffer, user.language)
          - Edit processing message to show transcription text
          - Get team for user, call analyzeVoiceRouting(result.text, team.id, user.language)
          - Build InlineKeyboard from routing suggestions:
            - For each suggestion: button with text "{type}: {projectName || 'New Idea'} ({confidence}%)"
            - Callback data: "vr:{suggestion.type}:{suggestion.projectId || 'new'}"
          - Send new message with routing suggestions keyboard
          - On error: edit processing message with error text

       e. Register callback handler for "vr:" prefix:
          - "vr:existing_project:{projectId}" -> reply with "Routed to {projectName}. Use /projects to view."
            (NOTE: actual routing integration to append transcription to project happens in Plan 05)
          - "vr:idea_pool:new" -> create new idea via appendEvent with idea.created, reply with confirmation
          - Answer callback query

       Register: bot.on("message:voice", handleVoiceMessage)
       Also handle bot.on("message:voice_note") for video voice notes if applicable.

       Export handleVoiceMessage.

    2. Create server/src/telegram/handlers/text.ts:
       - Import BotContext from ../types.js
       - Import resolveElumaUser from ../auth.js
       - Import completeWorkflowStep from workflow/engine.js

       handleTextMessage(ctx: BotContext): async function
       - Check session.pendingWorkflowInput. If exists:
         a. Extract projectId, stepId, fieldKey from pending input
         b. Call completeWorkflowStep(projectId, stepId, { [fieldKey]: ctx.message.text }, userId)
         c. Clear session.pendingWorkflowInput
         d. Reply with step completion confirmation
         e. Render next workflow step (import and call workflow menu rendering logic)
       - If no pending input:
         a. Reply with "Use /help to see available commands, or send a voice message to capture an idea."

       Register: bot.on("message:text", handleTextMessage)
       IMPORTANT: Register AFTER command handlers so commands take priority over generic text handler.

       Export handleTextMessage.
  </action>
  <verify>cd /Users/developer/eluma && npx tsc --noEmit</verify>
  <done>Voice messages download OGG from Telegram, transcribe via existing pipeline, show routing suggestions as buttons. Text messages route to pending workflow steps or show help. Fire-and-forget pattern prevents webhook timeout.</done>
</task>

</tasks>

<verification>
- `cd /Users/developer/eluma && npx tsc --noEmit` compiles without errors
- `grep "transcribeAudio" server/src/telegram/handlers/voice.ts` confirms reuse of existing pipeline
- `grep "analyzeVoiceRouting" server/src/telegram/handlers/voice.ts` confirms reuse of existing routing
- `grep "completeWorkflowStep" server/src/telegram/handlers/callback.ts server/src/telegram/menus/workflow-menu.ts` confirms direct function calls
- `grep "pendingWorkflowInput" server/src/telegram/handlers/text.ts` confirms workflow text input routing
</verification>

<success_criteria>
- Workflow steps render as appropriate Telegram UI: buttons for choices, text prompts for input, auto-advance for automated
- Voice messages acknowledged immediately, transcribed in background, routing suggestions presented as inline buttons
- Fire-and-forget pattern: webhook handler completes within 10 seconds, follow-up messages sent async
- Free text routed to pending workflow input steps when session state exists
- Existing voice transcription and routing analysis functions reused directly (no HTTP self-calls)
- Existing workflow engine used directly for step completion
</success_criteria>

<output>
After completion, create `.planning/phases/07-telegram-bot-notifications/07-04-SUMMARY.md`
</output>
