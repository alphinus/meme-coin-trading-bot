---
phase: 04-ai-foundation-orchestration
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - server/src/ai/triggers/types.ts
  - server/src/ai/triggers/rules.ts
  - server/src/ai/triggers/engine.ts
  - server/src/ai/actions/reflection.ts
  - server/src/ai/actions/notification.ts
  - server/src/ai/actions/mediation.ts
  - server/src/docs/writer.ts
  - server/src/routes/projects.ts
  - server/src/routes/teams.ts
  - server/src/routes/docs.ts
autonomous: true

must_haves:
  truths:
    - "AI acts only on defined trigger rules matching domain events"
    - "AI never triggers on its own events (no feedback loops)"
    - "Trigger evaluation uses correlationId deduplication to prevent duplicate AI responses"
    - "AI reflections appear as ai_reflection entries in Soul Documents"
    - "AI face emoji activates when a trigger fires a notification action"
    - "AI mediates team conflicts by analyzing two positions and proposing compromise"
  artifacts:
    - path: "server/src/ai/triggers/engine.ts"
      provides: "Trigger evaluation engine (evaluateTriggersForEvent)"
      exports: ["evaluateTriggersForEvent"]
    - path: "server/src/ai/triggers/rules.ts"
      provides: "Hardcoded trigger rule definitions"
      exports: ["loadTriggerRules"]
    - path: "server/src/ai/actions/reflection.ts"
      provides: "AI reflection action writing to Soul Documents"
      exports: ["generateReflection"]
    - path: "server/src/ai/actions/mediation.ts"
      provides: "Conflict mediation action"
      exports: ["mediateConflict"]
    - path: "server/src/docs/writer.ts"
      provides: "Updated EVENT_TO_ENTRY_MAP with ai.response_generated mapping"
      contains: "ai.response_generated"
  key_links:
    - from: "server/src/ai/triggers/engine.ts"
      to: "server/src/ai/actions/reflection.ts"
      via: "rule.action dispatch"
      pattern: "generateReflection"
    - from: "server/src/ai/actions/reflection.ts"
      to: "server/src/docs/writer.ts"
      via: "writeSoulDocumentEntry with sourceType ai_reflection"
      pattern: "writeSoulDocumentEntry"
    - from: "server/src/routes/projects.ts"
      to: "server/src/ai/triggers/engine.ts"
      via: "evaluateTriggersForEvent fire-and-forget after appendEvent"
      pattern: "evaluateTriggersForEvent"
    - from: "server/src/ai/triggers/engine.ts"
      to: "server/src/ai/triggers/engine.ts"
      via: "Skip ai.* events to prevent loops"
      pattern: "event\\.type\\.startsWith.*ai\\."
---

<objective>
Build the AI trigger engine, AI actions (reflection, notification, mediation), and wire trigger evaluation into existing route handlers using the fire-and-forget pattern.

Purpose: This is the behavioral core of the AI team member. It implements the rule-bound trigger system (AI-05), AI reflections feeding Soul Documents (Phase 3 integration), the notification mechanism (AI-02 face emoji), and conflict mediation (AI-11). Triggers are wired into existing routes the same way processEventForDocumentation was wired in Phase 3.

Output: Trigger engine, 3 AI actions, trigger wiring in existing routes, Soul Document writer updated for AI events
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-foundation-orchestration/04-RESEARCH.md
@.planning/phases/03-documentation-engine/03-01-SUMMARY.md
@.planning/phases/03-documentation-engine/03-02-SUMMARY.md

# Key files to modify/reference
@eluma/server/src/docs/writer.ts
@eluma/server/src/routes/projects.ts
@eluma/server/src/routes/teams.ts
@eluma/server/src/routes/docs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trigger engine with rules and deduplication</name>
  <files>
    server/src/ai/triggers/types.ts
    server/src/ai/triggers/rules.ts
    server/src/ai/triggers/engine.ts
  </files>
  <action>
1. Create `server/src/ai/triggers/types.ts`:
   - Import `DomainEvent` from "shared/types/events.js"
   - Export `TriggerContext` interface: { event: DomainEvent; timestamp: string }
   - Export `TriggerResult` interface: { triggered: boolean; action: string; context: Record<string, unknown> }
   - Export `TriggerRule` interface: { id: string; name: string; type: "milestone" | "pattern" | "conflict" | "catch"; matches: (ctx: TriggerContext) => boolean; action: string; description: string }

2. Create `server/src/ai/triggers/rules.ts`:
   - Import TriggerRule from "./types.js"
   - Export `function loadTriggerRules(): TriggerRule[]` returning an array of hardcoded rules:

   a. **milestone_phase_completed** (type: "milestone"):
      - Matches: event.type === "project.phase_completed"
      - Action: "reflection"
      - Description: "Generate AI reflection when a project phase is completed"

   b. **milestone_project_archived** (type: "milestone"):
      - Matches: event.type === "project.archived"
      - Action: "reflection"
      - Description: "Generate AI reflection when a project is archived (review extraction complete)"

   c. **pattern_kpi_added** (type: "pattern"):
      - Matches: event.type === "project.roi_kpi_added"
      - Action: "notification"
      - Description: "AI notifies when a KPI is recorded (may want to analyze trends)"

   d. **catch_new_member** (type: "catch"):
      - Matches: event.type === "team.member_added"
      - Action: "notification"
      - Description: "AI welcomes new team member"

   e. **conflict_mediation** (type: "conflict"):
      - Matches: event.type === "ai.trigger_fired" && event.data.triggerType === "mediation_request"
      - Action: "mediation"
      - Description: "AI mediates when a disagreement is flagged"

   NOTE: These are v1 starter rules. The interface is extensible -- more rules can be added without architecture changes.

3. Create `server/src/ai/triggers/engine.ts`:
   - Import loadTriggerRules from "./rules.js"
   - Import TriggerContext from "./types.js"
   - Import DomainEvent from "shared/types/events.js"
   - Import { generateReflection } from "../actions/reflection.js"
   - Import { triggerNotification } from "../actions/notification.js"
   - Import { mediateConflict } from "../actions/mediation.js"
   - Import { appendEvent } from "../../events/store.js"
   - Import { AI_SYSTEM_USER_ID } from "../config.js"

   - Create a module-level `recentCorrelationIds` Map<string, number> for deduplication (correlationId -> timestamp)
   - Create a cleanup interval: every 10 seconds, remove entries older than 5 seconds from the map

   - Export `async function evaluateTriggersForEvent(event: DomainEvent): Promise<void>`:
     a. CRITICAL: Skip all ai.* events: `if (event.type.startsWith("ai.")) return;`
     b. CRITICAL: Skip all soul_document.* events: `if (event.type.startsWith("soul_document.")) return;`
     c. Check correlationId deduplication: if recentCorrelationIds has event.correlationId, skip. Otherwise add it.
     d. Build TriggerContext from event
     e. Loop through loadTriggerRules(), check rule.matches(context)
     f. For each matching rule:
        - Append "ai.trigger_fired" event (fire-and-forget tracking)
        - Dispatch to action handler based on rule.action:
          - "reflection" -> generateReflection(event)
          - "notification" -> triggerNotification(event, rule)
          - "mediation" -> mediateConflict(...) (extract positions from event data)
        - Wrap each action dispatch in try/catch -- log errors but never throw (fire-and-forget)
     g. All action dispatches are fire-and-forget (no await propagation to caller)

   IMPORTANT: The engine function itself is async but callers should NOT await it. It runs fire-and-forget just like processEventForDocumentation in Phase 3.
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- TypeScript compiles. Verify engine.ts skips ai.* and soul_document.* events. Verify deduplication map exists. Verify all 5 rules are defined.
  </verify>
  <done>
    Trigger engine evaluates domain events against 5 hardcoded rules with correlationId deduplication. AI events and soul_document events are always skipped to prevent feedback loops. Actions dispatched via fire-and-forget.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI actions and wire triggers into existing routes</name>
  <files>
    server/src/ai/actions/reflection.ts
    server/src/ai/actions/notification.ts
    server/src/ai/actions/mediation.ts
    server/src/docs/writer.ts
    server/src/routes/projects.ts
    server/src/routes/teams.ts
    server/src/routes/docs.ts
  </files>
  <action>
1. Create `server/src/ai/actions/reflection.ts`:
   - Import generateAiResponse from "../generate.js"
   - Import writeSoulDocumentEntry from "../../docs/writer.js"
   - Import { getTeamForUser } from "../../events/reducers/team.js"
   - Import { getAiMemberConfig } from "../../events/reducers/ai-member.js"
   - Import { AI_SYSTEM_USER_ID } from "../config.js"

   - Export `async function generateReflection(event: DomainEvent): Promise<void>`:
     a. Resolve teamId from event.userId via getTeamForUser (same pattern as writer.ts)
     b. If no team, return silently
     c. Get AI member config for team (use default language "en" if no config)
     d. Build system prompt: "You are {config.name}, an AI team member. {config.character}. Analyze the following event and provide a brief, thoughtful reflection on what it means for the project and team. Focus on patterns, implications, or suggestions."
     e. Build user prompt from event type and data (format event details into a readable summary)
     f. Call generateAiResponse with taskType "reflection", projectId from event
     g. Write result to Soul Document via writeSoulDocumentEntry:
        - userId = event.userId (the person whose action triggered the reflection)
        - sourceType = "ai_reflection"
        - content = "**AI Reflection:**\n\n" + response text
        - triggerEventId = event.id, triggerEventType = event.type

2. Create `server/src/ai/actions/notification.ts`:
   - Import appendEvent from "../../events/store.js"
   - Import { AI_SYSTEM_USER_ID } from "../config.js"
   - Import TriggerRule from "../triggers/types.js"

   - Export `async function triggerNotification(event: DomainEvent, rule: TriggerRule): Promise<void>`:
     a. Determine notification category from rule.type: "milestone"->"suggestion", "pattern"->"thinking", "catch"->"suggestion", "conflict"->"mediation"
     b. Append "ai.message_pending" event with aggregateType "ai_member", aggregateId = teamId (extract from event context), data = { category, ruleId: rule.id, ruleName: rule.name, triggerEventId: event.id, triggerEventType: event.type, messageId: randomUUID() }
     c. This sets the face emoji state so the dashboard shows AI has something to say

3. Create `server/src/ai/actions/mediation.ts`:
   - Import generateAiResponse from "../generate.js"
   - Import writeSoulDocumentEntry from "../../docs/writer.js"
   - Import appendEvent from "../../events/store.js"
   - Import { AI_SYSTEM_USER_ID } from "../config.js"
   - Import { getAiMemberConfig } from "../../events/reducers/ai-member.js"

   - Export interface `MediationInput`: { projectId, teamId, language, position1: { userId, summary }, position2: { userId, summary }, projectContext, correlationId }

   - Export `async function mediateConflict(input: MediationInput): Promise<{ text: string; eventId: string }>`:
     a. Get AI member config for team
     b. Build system prompt for neutral mediation (from research)
     c. Build user prompt with both positions and project context
     d. Call generateAiResponse with taskType "mediation"
     e. Write mediation result to Soul Documents of BOTH participants (sourceType "ai_reflection")
     f. Append "ai.mediation_completed" event
     g. Return { text, eventId }

4. Update `server/src/docs/writer.ts`:
   - Add new entry to EVENT_TO_ENTRY_MAP for "ai.response_generated":
     ```
     "ai.response_generated": (event) => {
       const data = event.data as { taskType: string; text: string };
       return {
         sourceType: "ai_reflection",
         content: `**AI ${data.taskType}:**\n\n${data.text}`,
       };
     },
     ```
   - Replace the Phase 4 placeholder comment with this actual mapping
   - CRITICAL: processEventForDocumentation already skips soul_document.* events. It does NOT skip ai.* events (the ai.response_generated event should create a Soul Document entry). However, the trigger engine DOES skip ai.* events, so no loop occurs: event -> trigger -> AI response -> ai.response_generated event -> Soul Document entry (via writer), but trigger engine ignores ai.response_generated.

5. Wire `evaluateTriggersForEvent` into existing route handlers (same fire-and-forget pattern as processEventForDocumentation):
   - In `server/src/routes/projects.ts`: Add import of evaluateTriggersForEvent. After each appendEvent + processEventForDocumentation call, add `evaluateTriggersForEvent(event);` (no await). Apply to: project.created, project.updated, project.phase_completed, project.phase_advanced, project.roi_kpi_added, project.archived.
   - In `server/src/routes/teams.ts`: Add same wiring after appendEvent calls for: team.created, team.member_added.
   - In `server/src/routes/docs.ts`: Add wiring after soul_document.entry_manual appendEvent call. NOTE: The trigger engine skips soul_document.* events anyway, but wiring it maintains consistency. Actually, since the engine skips these, do NOT wire docs.ts -- it would be dead code. Only wire projects.ts and teams.ts.

IMPORTANT on the wiring pattern:
```typescript
const event = appendEvent({ ... });
processEventForDocumentation(event);  // existing
evaluateTriggersForEvent(event);       // new -- same fire-and-forget, no await
```
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- TypeScript compiles. Verify writer.ts has the ai.response_generated mapping in EVENT_TO_ENTRY_MAP. Verify projects.ts and teams.ts have evaluateTriggersForEvent calls after each relevant appendEvent. Count: should be 6 calls in projects.ts and 2-3 in teams.ts.
  </verify>
  <done>
    Three AI actions (reflection, notification, mediation) implemented. Trigger engine wired into projects.ts and teams.ts route handlers via fire-and-forget. Soul Document writer maps AI response events to ai_reflection entries. AI reflections appear in team members' Soul Documents when milestones are reached.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --build --noEmit` passes from project root
- Trigger engine skips ai.* and soul_document.* events (verified in source)
- CorrelationId deduplication prevents duplicate AI responses
- evaluateTriggersForEvent wired in projects.ts (6 calls) and teams.ts (2-3 calls)
- writer.ts EVENT_TO_ENTRY_MAP has "ai.response_generated" entry replacing placeholder comment
- All three actions (reflection, notification, mediation) handle errors via try/catch without crashing
</verification>

<success_criteria>
- AI trigger engine evaluates domain events against 5 rules
- Phase completed -> AI generates reflection in Soul Document
- KPI added -> AI sets face emoji notification
- New team member -> AI notification
- Mediation request -> AI analyzes both positions and writes compromise to both Soul Documents
- No feedback loops possible (ai.* and soul_document.* events always skipped)
- CorrelationId deduplication prevents duplicate responses for same event chain
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-foundation-orchestration/04-03-SUMMARY.md`
</output>
