---
phase: 04-ai-foundation-orchestration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/events.ts
  - server/src/events/reducers/ai-member.ts
  - server/src/routes/ai.ts
  - server/src/app.ts
autonomous: true

must_haves:
  truths:
    - "AI event types exist in the shared event type system"
    - "AI member state is derived from events via a reducer"
    - "AI member configuration can be set and queried via API"
    - "AI member appears as a team entity with name, character, and emoji state"
  artifacts:
    - path: "shared/types/events.ts"
      provides: "9 new ai.* event types in EventType union and EVENT_TYPES array"
      contains: "ai.member_configured"
    - path: "server/src/events/reducers/ai-member.ts"
      provides: "AI member state reducer from events"
      exports: ["reduceAiMemberState", "getAiMemberConfig"]
    - path: "server/src/routes/ai.ts"
      provides: "AI configuration and status API routes"
      exports: ["default"]
    - path: "server/src/app.ts"
      provides: "AI routes wired at /api/ai"
      contains: "aiRouter"
  key_links:
    - from: "server/src/routes/ai.ts"
      to: "server/src/events/reducers/ai-member.ts"
      via: "getAiMemberConfig for GET endpoints"
      pattern: "getAiMemberConfig"
    - from: "server/src/routes/ai.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for configuration changes"
      pattern: "appendEvent"
    - from: "server/src/app.ts"
      to: "server/src/routes/ai.ts"
      via: "Express router wired at /api/ai"
      pattern: "app\\.use.*api/ai"
---

<objective>
Add AI event types to the shared type system and build the AI team member entity layer with an event-sourced reducer and API routes for configuration.

Purpose: The AI member entity (AI-01, AI-02) needs to exist as a first-class event-sourced entity before triggers, actions, or UI can reference it. The event types are needed by all other Phase 4 plans.

Output: AI event types in shared types, AI member reducer, AI configuration/status API routes wired into Express
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-foundation-orchestration/04-RESEARCH.md

# Integration points
@eluma/shared/types/events.ts
@eluma/shared/types/models.ts
@eluma/server/src/events/store.ts
@eluma/server/src/events/reducers/team.ts
@eluma/server/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI event types and create AI member reducer</name>
  <files>
    shared/types/events.ts
    server/src/events/reducers/ai-member.ts
  </files>
  <action>
1. Update `shared/types/events.ts`:
   - Add 9 new AI event types to the `EventType` union:
     ```
     | "ai.member_configured"
     | "ai.message_pending"
     | "ai.message_read"
     | "ai.response_generated"
     | "ai.cost_recorded"
     | "ai.model_overridden"
     | "ai.decision_overridden"
     | "ai.mediation_completed"
     | "ai.trigger_fired"
     ```
   - Add all 9 to the `EVENT_TYPES` array as well
   - Place them after the soul_document.* entries and before system.* entries to maintain grouping

2. Create `server/src/events/reducers/ai-member.ts`:
   - Import `readEvents` from "../store.js"
   - Import `AiMemberConfig` from "shared/types/ai.js"
   - Import `DomainEvent` from "shared/types/events.js"

   - Export `function reduceAiMemberState(events: DomainEvent[]): AiMemberConfig | null`:
     - Start with null state
     - Process events in order:
       - "ai.member_configured": Set name, character, language, teamId from event data. Initialize faceEmoji to "idle", hasMessage to false.
       - "ai.message_pending": Set hasMessage to true, faceEmoji to data.category (e.g., "thinking", "suggestion", "warning", "mediation"), pendingMessageId to data.messageId
       - "ai.message_read": Set hasMessage to false, faceEmoji to "idle", clear pendingMessageId
     - Return final state or null if no configuration event found

   - Export `async function getAiMemberConfig(teamId: string): Promise<AiMemberConfig | null>`:
     - Read events from aggregateType "ai_member" with aggregateId = teamId
     - Filter to only config-relevant events (ai.member_configured, ai.message_pending, ai.message_read)
     - Pass through reduceAiMemberState
     - Return result

   - Export `async function getAiMemberHasMessage(teamId: string): Promise<{ hasMessage: boolean; faceEmoji: string; pendingMessageId?: string }>`:
     - Convenience function that calls getAiMemberConfig and extracts message state
     - Returns { hasMessage: false, faceEmoji: "idle" } if no config exists
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- TypeScript compiles. Verify the 9 new event types appear in both the union and the array in events.ts. Verify reducer handles all three event types.
  </verify>
  <done>
    9 AI event types added to shared EventType union and EVENT_TYPES array. AI member reducer derives configuration state from events with message/emoji tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI configuration API routes and wire into Express</name>
  <files>
    server/src/routes/ai.ts
    server/src/app.ts
  </files>
  <action>
1. Create `server/src/routes/ai.ts` with Express Router:
   - Import Router from "express", z from "zod", appendEvent from "../events/store.js", getAiMemberConfig from "../events/reducers/ai-member.js"
   - Import requireAuth middleware pattern (already applied at app.ts level, but validate session userId exists)

   **GET /config/:teamId** -- Get AI member configuration for a team
   - Call getAiMemberConfig(teamId)
   - If null, return default config: { name: "AI", character: "Helpful and analytical team member", language: "en", faceEmoji: "idle", hasMessage: false, teamId }
   - Return { success: true, data: config }

   **POST /config/:teamId** -- Configure AI member (AI-01)
   - Validate body with Zod schema: { name: string (1-50 chars), character: string (1-500 chars), language: "de" | "en" }
   - Append "ai.member_configured" event with aggregateType "ai_member", aggregateId = teamId, userId from session, data = { name, character, language, teamId }
   - Return { success: true, data: { eventId: event.id } }

   **GET /status/:teamId** -- Get AI message status (AI-02 face emoji)
   - Call getAiMemberConfig(teamId)
   - Return { success: true, data: { hasMessage, faceEmoji, pendingMessageId } }
   - Default to { hasMessage: false, faceEmoji: "idle" } if no config

   **POST /message-read/:teamId** -- Mark AI message as read (AI-02)
   - Append "ai.message_read" event with aggregateType "ai_member", aggregateId = teamId
   - Return { success: true }

   Export default router.

2. Update `server/src/app.ts`:
   - Add import: `import aiRouter from "./routes/ai.js";`
   - Add route mounting: `app.use("/api/ai", requireAuth, aiRouter);`
   - Place after the existing /api/docs route for consistent ordering
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- TypeScript compiles. Verify app.ts imports aiRouter and mounts at /api/ai. Verify all 4 routes have proper Zod validation and error handling.
  </verify>
  <done>
    AI configuration API with 4 endpoints (GET/POST config, GET status, POST message-read) wired at /api/ai with requireAuth. AI member can be configured per team and message state queried for dashboard face emoji.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --build --noEmit` passes from project root
- `shared/types/events.ts` contains all 9 ai.* event types in both union and array
- `server/src/events/reducers/ai-member.ts` exports reduceAiMemberState and getAiMemberConfig
- `server/src/routes/ai.ts` has 4 endpoints with proper validation
- `server/src/app.ts` mounts aiRouter at /api/ai with requireAuth
</verification>

<success_criteria>
- 9 AI event types registered in shared type system
- AI member state derived from events via reducer (follows existing team/project reducer patterns)
- AI configuration and status queryable via REST API
- Face emoji state (hasMessage) trackable through events
- Express app wires AI routes with authentication
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-foundation-orchestration/04-02-SUMMARY.md`
</output>
