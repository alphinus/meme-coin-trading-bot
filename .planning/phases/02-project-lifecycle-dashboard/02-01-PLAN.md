---
phase: 02-project-lifecycle-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/events.ts
  - shared/types/models.ts
  - server/src/events/reducers/project.ts
  - server/src/routes/projects.ts
  - server/src/app.ts
autonomous: true

must_haves:
  truths:
    - "Projects can be created via POST /api/projects with name, description, and members"
    - "Projects progress through 8 lifecycle phases in strict order via POST /api/projects/:id/advance"
    - "No phase can be skipped -- server rejects out-of-order advances"
    - "ROI/KPI entries can be added to a project and retrieved per-phase and aggregated"
    - "Completed projects (post review_extraction) are automatically archived"
    - "Dashboard overview endpoint returns status distribution and aggregated KPIs in a single call"
  artifacts:
    - path: "shared/types/models.ts"
      provides: "ProjectState, PhaseData, RoiKpiEntry, PROJECT_PHASES types"
      contains: "PROJECT_PHASES"
    - path: "shared/types/events.ts"
      provides: "New event types for project lifecycle"
      contains: "project.phase_completed"
    - path: "server/src/events/reducers/project.ts"
      provides: "Project state reducer with lifecycle enforcement"
      exports: ["reduceProjectState", "getProjectById", "getAllProjects"]
    - path: "server/src/routes/projects.ts"
      provides: "Project CRUD + lifecycle + metrics API routes"
      exports: ["default"]
    - path: "server/src/app.ts"
      provides: "Projects router wired into Express app"
      contains: "projectsRouter"
  key_links:
    - from: "server/src/routes/projects.ts"
      to: "server/src/events/reducers/project.ts"
      via: "getProjectById, getAllProjects"
      pattern: "getProjectById|getAllProjects"
    - from: "server/src/routes/projects.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for project mutations"
      pattern: "appendEvent"
    - from: "server/src/app.ts"
      to: "server/src/routes/projects.ts"
      via: "Express router registration"
      pattern: "app\\.use.*api/projects"
---

<objective>
Build the complete backend for project lifecycle management: shared types for the 8-phase lifecycle state machine, an event-sourced project reducer, and all API routes for project CRUD, phase advancement, ROI/KPI tracking, and dashboard overview.

Purpose: This is the foundation that all Phase 2 frontend plans depend on. The lifecycle state machine, phase transition validation, and metrics aggregation must be correct and complete before any UI work begins.
Output: Working API at /api/projects with full lifecycle support, testable via curl.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-project-lifecycle-dashboard/02-RESEARCH.md
@eluma/shared/types/events.ts
@eluma/shared/types/models.ts
@eluma/server/src/events/store.ts
@eluma/server/src/events/reducers/team.ts
@eluma/server/src/routes/teams.ts
@eluma/server/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project lifecycle types and event-sourced reducer</name>
  <files>
    shared/types/models.ts
    shared/types/events.ts
    server/src/events/reducers/project.ts
  </files>
  <action>
    1. In shared/types/models.ts, ADD (do not remove existing types):
       - PROJECT_PHASES const array: ["idea", "feasibility", "effort_estimate", "roi_kpi_initial", "risks_dependencies", "decision_point", "implementation", "review_extraction"] as const
       - ProjectPhase type derived from PROJECT_PHASES
       - PhaseData interface: { phase: ProjectPhase; enteredAt: string; completedAt?: string; data: Record<string, unknown> }
       - RoiKpiEntry interface: { id: string; category: string; label: string; value: number; unit: string; phase: ProjectPhase; decisionId?: string; recordedAt: string }
       - ProjectState interface: { id: string; name: string; description: string; teamId: string; members: string[]; currentPhase: ProjectPhase; phases: PhaseData[]; roiKpis: RoiKpiEntry[]; archived: boolean; createdAt: string; updatedAt: string }
       - Keep the existing Project interface (it is used elsewhere) but ProjectState is the event-sourced projection used in Phase 2+

    2. In shared/types/events.ts, ADD new event types to the EventType union and EVENT_TYPES array:
       - "project.phase_completed"
       - "project.phase_advanced"
       - "project.roi_kpi_added"
       - "project.roi_kpi_updated"
       - "project.archived"
       - "project.member_added"
       Note: "project.created" and "project.updated" already exist -- do NOT duplicate them.

    3. Create server/src/events/reducers/project.ts following the exact pattern from team.ts:
       - reduceProjectState(events: DomainEvent[]): ProjectState | null
         - Handles: project.created (sets initial state with currentPhase="idea", empty phases array with idea entry), project.updated, project.phase_completed, project.phase_advanced, project.roi_kpi_added, project.roi_kpi_updated, project.archived, project.member_added
         - Returns null if no project.created event found
       - getProjectById(projectId: string): Promise<ProjectState | null> -- reads events for "project" aggregate, sorts chronologically, reduces
       - getAllProjects(): Promise<ProjectState[]> -- reads ALL "project" events, groups by aggregateId, reduces each group, returns array
       - getProjectsForTeam(teamId: string): Promise<ProjectState[]> -- filters getAllProjects by teamId
       - getNextPhase(current: ProjectPhase): ProjectPhase | null -- returns next phase in sequence, or null if current is "review_extraction"
       - getCurrentVersion(projectId: string): Promise<number> -- returns count of events for optimistic concurrency
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- TypeScript compiles without errors.
    Verify the PROJECT_PHASES array has exactly 8 entries.
    Verify reduceProjectState handles all 8 event types listed above.
  </verify>
  <done>
    ProjectState, PhaseData, RoiKpiEntry types exist in shared/types/models.ts. All 6 new event types exist in events.ts. Project reducer compiles and handles all event types. getProjectById, getAllProjects, getProjectsForTeam, getNextPhase, getCurrentVersion are all exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create project API routes and wire into Express app</name>
  <files>
    server/src/routes/projects.ts
    server/src/app.ts
  </files>
  <action>
    1. Create server/src/routes/projects.ts following the exact pattern from teams.ts (Router, zod validation, appendEvent, ApiResponse typing):

       Validation schemas:
       - createProjectSchema: { name: string (min 1, max 100), description: string (min 1, max 2000), members: string[] (optional, defaults to []) }
       - updateProjectSchema: { name?: string, description?: string }
       - addKpiSchema: { category: string (min 1), label: string (min 1), value: number, unit: string (min 1), decisionId?: string }

       Routes:
       a) POST / -- Create project. Requires req.user. Gets user's team via getTeamForUser. Creates project with teamId. Emits project.created event (data: { name, description, teamId, members: [req.user.id, ...members] }). Returns 201 with ProjectState.

       b) GET / -- List projects for user's team. Gets team via getTeamForUser, then getProjectsForTeam(team.id). Returns array of ProjectState. Separate into active and archived in response: { active: ProjectState[], archived: ProjectState[] }.

       c) GET /dashboard/overview -- IMPORTANT: Register this BEFORE /:id to avoid route conflict. Calls getAllProjects (filtered by user's team). Computes: statusDistribution (map of phase -> count, archived projects count as "archived"), aggregatedKpis (summed by category+unit), totalProjects, activeProjects, archivedProjects. Returns single response object.

       d) GET /:id -- Get single project by ID. Returns ProjectState.

       e) PUT /:id -- Update project name/description. Validates ownership (project.teamId matches user's team). Emits project.updated event.

       f) POST /:id/advance -- Advance project to next phase. Uses getNextPhase(). If null AND current phase is "review_extraction", emit project.phase_completed then project.archived. If null for other reason, return 400. Otherwise emit project.phase_completed (with req.body.phaseData || {}) then project.phase_advanced (data: { nextPhase }). Use optimistic concurrency: getCurrentVersion to set version. Return updated ProjectState.

       g) GET /:id/metrics -- Get ROI/KPI metrics for project. Returns { total: RoiKpiEntry[], byPhase: Record<string, RoiKpiEntry[]>, byDecision: Record<string, RoiKpiEntry[]> }.

       h) POST /:id/kpi -- Add ROI/KPI entry. Server auto-populates phase from project's currentPhase (do NOT trust client-sent phase). Generates kpiId via randomUUID(). Emits project.roi_kpi_added event. Returns updated metrics.

    2. In server/src/app.ts:
       - Add import: import projectsRouter from "./routes/projects.js";
       - Uncomment/replace the commented-out line: app.use("/api/projects", requireAuth, projectsRouter);
       - Place it after the teams router registration.

    Note: For the advance endpoint, emit TWO events in sequence (phase_completed then phase_advanced) with the same correlationId, just like the research recommends. The server MUST validate that the advance is sequential -- the client cannot specify which phase to advance to.
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --build --noEmit` -- compiles without errors.
    Start the server: `cd /Users/developer/eluma && npm run dev &` then test:
    1. Create a project: `curl -s -b /tmp/cookies.txt -X POST http://localhost:3000/api/projects -H "Content-Type: application/json" -d '{"name":"Test Project","description":"A test"}' | head -c 500`
    2. List projects: `curl -s -b /tmp/cookies.txt http://localhost:3000/api/projects | head -c 500`
    3. Get dashboard overview: `curl -s -b /tmp/cookies.txt http://localhost:3000/api/projects/dashboard/overview | head -c 500`
    If auth is needed for curl, log in first via the auth endpoint to get session cookies.
  </verify>
  <done>
    All 8 API endpoints compile and are wired into Express. POST /api/projects creates a project with lifecycle starting at "idea" phase. POST /api/projects/:id/advance moves to the next sequential phase and rejects skips. POST /api/projects/:id/kpi adds KPI entries. GET /api/projects/dashboard/overview returns aggregated data in a single call. Project completing review_extraction phase is auto-archived.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `cd /Users/developer/eluma && npx tsc --build --noEmit`
- Server starts without errors: `cd /Users/developer/eluma && npm run dev`
- API endpoints respond (via curl or browser dev tools)
- Phase advancement is strictly sequential (advancing from idea goes to feasibility, not any arbitrary phase)
- Completing review_extraction auto-archives the project
</verification>

<success_criteria>
- All project lifecycle API routes are functional and accessible at /api/projects/*
- Phase transitions are server-enforced in strict 8-phase order with no skipping
- ROI/KPI entries are attached to the correct phase automatically
- Dashboard overview returns aggregated data in a single API call
- TypeScript compiles cleanly with all new types
</success_criteria>

<output>
After completion, create `.planning/phases/02-project-lifecycle-dashboard/02-01-SUMMARY.md`
</output>
