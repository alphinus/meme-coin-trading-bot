---
phase: 11-telegram-bot-i18n
plan: 04
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - server/src/telegram/handlers/text.ts
  - server/src/telegram/handlers/voice.ts
  - server/src/telegram/handlers/callback.ts
  - server/src/notifications/emitter.ts
autonomous: true

must_haves:
  truths:
    - "Text handler messages use ctx.t() for all user-facing strings"
    - "Voice handler messages use ctx.t() for bot-context strings and i18n.t() for background messages"
    - "Callback handler messages use ctx.t() for all user-facing strings"
    - "Notification emitter resolves per-recipient language and translates title+body via i18n.t()"
  artifacts:
    - path: "server/src/telegram/handlers/text.ts"
      provides: "i18n-enabled text message handler"
      contains: "ctx.t("
    - path: "server/src/telegram/handlers/voice.ts"
      provides: "i18n-enabled voice message handler"
      contains: "ctx.t("
    - path: "server/src/telegram/handlers/callback.ts"
      provides: "i18n-enabled callback query handler"
      contains: "ctx.t("
    - path: "server/src/notifications/emitter.ts"
      provides: "i18n-enabled notification emitter with per-user language resolution"
      contains: "i18n.t("
  key_links:
    - from: "server/src/notifications/emitter.ts"
      to: "server/src/telegram/i18n.ts"
      via: "imports i18n instance for standalone translation"
      pattern: "import.*i18n.*from.*telegram/i18n"
    - from: "server/src/notifications/emitter.ts"
      to: "server/src/auth/users.ts"
      via: "loadUser for per-recipient language resolution"
      pattern: "loadUser"
---

<objective>
Replace all hardcoded English strings in the three handler files and the notification emitter with translated equivalents. Handlers use ctx.t(); the emitter uses i18n.t(locale, key) since it runs outside bot context.

Purpose: Handlers process text messages, voice messages, and callback queries -- all user-facing. The emitter generates all notification text that flows through Telegram, web, and email channels. This plan ensures 100% of bot output respects language preference.

Output: All 3 handler files and emitter.ts fully i18n-enabled.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-telegram-bot-i18n/11-RESEARCH.md
@.planning/phases/11-telegram-bot-i18n/11-01-SUMMARY.md

@server/src/telegram/handlers/text.ts
@server/src/telegram/handlers/voice.ts
@server/src/telegram/handlers/callback.ts
@server/src/notifications/emitter.ts
@server/src/telegram/i18n.ts
@server/src/telegram/locales/de.ftl
@server/src/telegram/locales/en.ftl
</context>

<tasks>

<task type="auto">
  <name>Task 1: i18n for text.ts, voice.ts, and callback.ts handlers</name>
  <files>
    server/src/telegram/handlers/text.ts
    server/src/telegram/handlers/voice.ts
    server/src/telegram/handlers/callback.ts
  </files>
  <action>
**Update handlers/text.ts:**
Replace all hardcoded strings with `ctx.t()` calls:
- `"Your Telegram account is not linked to Eluma. Use /link <code> to connect."` -> `ctx.t("handler-not-linked")`
- `"Please send a text message."` -> `ctx.t("handler-send-text")`
- `"Got it!"` -> `ctx.t("handler-got-it")`
- `"Error: ${message}"` -> `ctx.t("handler-step-error", { message })`
- `"Use /help to see available commands, or send a voice message to capture an idea."` -> `ctx.t("handler-help-hint")`

**Update handlers/voice.ts:**

In `handleVoiceMessage()`:
- `"Your Telegram account is not linked to Eluma. Use /link <code> to connect."` -> `ctx.t("handler-not-linked")`
- `"Transcribing your voice message..."` -> `ctx.t("handler-transcribing")`
- The error message in `.catch()` uses `bot.api.editMessageText` (outside ctx) -- for this background error, import `i18n` from `../i18n.js` and use `i18n.t(user.language, "handler-transcribe-error")`. But since we're in the catch and may not have user language, use the defaultLocale or capture language before the background task. Simplest: capture `const userLang = user.language` before spawning background, pass it to `processVoiceInBackground`, and use `i18n.t(userLang, ...)` for error messages in the background task.

In `processVoiceInBackground()`:
- Add `userLang: "de" | "en"` parameter (already has `language` param, rename for clarity or reuse)
- `"No voice data found in message."` -> `i18n.t(language, "handler-no-voice")`
- `"Failed to download voice file from Telegram."` -> `i18n.t(language, "handler-download-failed")`
- `"*Transcription:*"` -> keep as markdown formatting label, translate: `i18n.t(language, "handler-transcription-label")`
- `"Could not determine your team for routing analysis."` -> `i18n.t(language, "handler-no-team-route")`
- `"No routing suggestions available. Your transcription has been saved."` -> `i18n.t(language, "handler-no-routing")`
- `"Where should this go?"` -> `i18n.t(language, "handler-where-should-go")`
- `"Project: ${s.projectName} (${s.confidence}%)"` -> `i18n.t(language, "handler-route-project", { name: s.projectName, confidence: s.confidence })`
- `"Idea Pool: New Idea (${s.confidence}%)"` -> `i18n.t(language, "handler-route-idea-pool", { confidence: s.confidence })`

In `handleVoiceRoutingCallback()`:
- `"Invalid action."` -> `ctx.t("cb-invalid-action")`
- `"Account not linked. Use /link first."` -> `ctx.t("handler-not-linked")`
- `"Routed!"` -> `ctx.t("handler-routed")`
- `"Routed to project. Use /projects to view."` -> `ctx.t("handler-route-project-done")`
- `"Voice idea from Telegram"` (idea title) -> `ctx.t("handler-voice-idea-title")`
- `"Captured via Telegram voice message"` (raw input) -> `ctx.t("handler-voice-idea-raw")`
- `"Idea created!"` -> `ctx.t("handler-idea-created")`
- `"New idea added to the Idea Pool! Use the web app to refine it."` -> `ctx.t("handler-idea-web-refine")`
- `"Team not found."` -> `ctx.t("error-no-team")`
- `"Unknown routing option."` -> `ctx.t("handler-unknown-route")`

Import `i18n` from `"../i18n.js"` in voice.ts for background message translations.

**Update handlers/callback.ts:**
Replace all hardcoded strings with `ctx.t()` calls:
- `"Invalid action."` -> `ctx.t("cb-invalid-action")`
- `"Invalid callback data."` -> `ctx.t("cb-invalid-data")`
- `"Please link your account first with /link."` -> `ctx.t("cb-link-first")`
- `"Step not found."` -> `ctx.t("cb-step-not-found")`
- `"No project selected. Use /projects first."` -> `ctx.t("cb-no-project")`
- `"Done!"` -> `ctx.t("cb-done")`
- Error message in catch: pass through as-is (it's a technical error from the engine)

NOTE: Add any new translation keys (handler-routed, handler-route-project-done, handler-voice-idea-title, handler-voice-idea-raw, handler-idea-created, handler-idea-web-refine, handler-unknown-route) to both de.ftl and en.ftl files.
  </action>
  <verify>
- `grep -c "ctx.t(" server/src/telegram/handlers/text.ts` shows 5+ translation calls
- `grep -c "ctx.t\|i18n.t(" server/src/telegram/handlers/voice.ts` shows 10+ translation calls
- `grep -c "ctx.t(" server/src/telegram/handlers/callback.ts` shows 6+ translation calls
- No hardcoded English UI strings remain in any handler file
- `npx tsc --noEmit` passes
  </verify>
  <done>All handler files use ctx.t() for user-facing strings; voice handler uses i18n.t() for background messages with user's language; all new keys added to both .ftl files; TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: i18n for notification emitter</name>
  <files>server/src/notifications/emitter.ts</files>
  <action>
Rewrite the `EVENT_NOTIFICATION_MAP` in `server/src/notifications/emitter.ts` to use `i18n.t(locale, key)` for per-recipient language-aware notifications.

1. Add imports at top:
```typescript
import { i18n } from "../telegram/i18n.js";
import { loadUser } from "../auth/users.js";
```

2. Change the `NotificationMapping` interface: instead of `title: string` and `body: (data) => string`, change to `titleKey: string` and `bodyKey: string` plus a `bodyParams` function that extracts Fluent variables from event data:
```typescript
interface NotificationMapping {
  priority: NotificationPriority;
  titleKey: string;
  bodyKey: string;
  bodyParams?: (data: Record<string, unknown>) => Record<string, unknown>;
}
```

3. Update `EVENT_NOTIFICATION_MAP` entries to use translation keys instead of English strings. For each entry:
   - `"project.created"`: `titleKey: "notif-new-project"`, `bodyKey: "notif-new-project-body"`, `bodyParams: (data) => ({ name: data.name ?? "Untitled" })`
   - `"project.phase_advanced"`: `titleKey: "notif-phase-advanced"`, `bodyKey: "notif-phase-advanced-body"`, `bodyParams: (data) => ({ name: data.projectName ?? "project", phase: String(data.toPhase ?? data.phase ?? "next phase").replace(/_/g, " ") })`
   - `"project.archived"`: `titleKey: "notif-project-archived"`, `bodyKey: "notif-project-archived-body"`, `bodyParams: (data) => ({ name: data.name ?? "project" })`
   - `"idea.created"`: `titleKey: "notif-new-idea"`, `bodyKey: "notif-new-idea-body"`, `bodyParams: (data) => ({ title: data.title ?? "Untitled" })`
   - `"idea.graduated"`: `titleKey: "notif-idea-graduated"`, `bodyKey: "notif-idea-graduated-body"`, `bodyParams: (data) => ({ title: data.ideaTitle ?? data.title ?? "idea" })`
   - `"idea.graduation_proposed"`: `titleKey: "notif-graduation-proposed"`, `bodyKey: "notif-graduation-proposed-body"`, `bodyParams: (data) => ({ title: data.ideaTitle ?? data.title ?? "idea" })`
   - `"idea.graduation_voted"`: `titleKey: "notif-graduation-voted"`, `bodyKey: "notif-graduation-voted-body"`, `bodyParams: (data) => ({ vote: String(data.vote ?? "unknown") })`
   - `"workflow.step_completed"`: `titleKey: "notif-workflow-step-completed"`, `bodyKey: "notif-workflow-step-body"`, `bodyParams: (data) => ({ step: String(data.stepId ?? "step").replace(/_/g, " ") })`
   - `"ai.trigger_fired"`: `titleKey: "notif-ai-alert"`, `bodyKey: "notif-ai-alert-body"`, `bodyParams: (data) => ({ message: String(data.message ?? data.summary ?? "") })`
   - `"ai.mediation_completed"`: `titleKey: "notif-ai-mediation"`, `bodyKey: "notif-ai-mediation-body"`, `bodyParams: (data) => ({ summary: String(data.summary ?? "") })`
   - Continue for all GitHub, Google, email integration events similarly

4. Update `emitNotificationForEvent()` to resolve per-recipient language:
```typescript
const dispatches = recipients.map(async (member) => {
  try {
    // Resolve recipient's language preference
    const recipientUser = loadUser(member.userId);
    const lang = recipientUser?.language ?? "de";

    // Translate title and body for this recipient's language
    const title = i18n.t(lang, mapping.titleKey);
    const params = mapping.bodyParams ? mapping.bodyParams(event.data) : {};
    const body = i18n.t(lang, mapping.bodyKey, params);

    await dispatchNotification({
      userId: member.userId,
      type: event.type,
      priority: mapping.priority,
      title,
      body,
      projectId: event.aggregateType === "project" ? event.aggregateId : undefined,
    });
  } catch (err) {
    console.error(`[emitter] Failed to dispatch notification to ${member.userId}:`, err);
  }
});
```

Note: `loadUser` (from `auth/users.ts`) is a synchronous file read -- fast and safe to call per recipient. For a 2-person team this adds negligible overhead.

IMPORTANT: The i18n.t() standalone method signature is `i18n.t(locale: string, key: string, params?: Record<string, FluentVariable>)`. Verify this matches the @grammyjs/i18n API. If the API differs, adapt accordingly.

IMPORTANT: Ensure the import of `i18n` from `../telegram/i18n.js` does NOT create a circular dependency. It should be safe because i18n.ts only imports from auth.ts and path, not from notifications.
  </action>
  <verify>
- `grep "i18n.t(" server/src/notifications/emitter.ts` shows per-recipient translation calls
- `grep "loadUser" server/src/notifications/emitter.ts` shows user language resolution
- `grep "titleKey\|bodyKey" server/src/notifications/emitter.ts` shows all mappings use keys
- No hardcoded English notification strings remain in EVENT_NOTIFICATION_MAP
- `npx tsc --noEmit` passes
  </verify>
  <done>Notification emitter resolves per-recipient language via loadUser().language; all EVENT_NOTIFICATION_MAP entries use translation keys; title and body translated via i18n.t(lang, key, params); no circular dependency introduced; TypeScript compiles</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` compiles without errors
- No hardcoded English UI strings in any of the 4 files
- Handler files use ctx.t() for all user-facing messages
- Voice handler uses i18n.t() for background messages
- Emitter resolves per-recipient language and translates via i18n.t()
- All new translation keys present in both de.ftl and en.ftl
</verification>

<success_criteria>
- Text handler responses respect user language preference
- Voice handler acknowledgments, transcription labels, and routing suggestions are translated
- Callback handler feedback messages are translated
- Notification titles and bodies are translated per-recipient in the recipient's preferred language
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-telegram-bot-i18n/11-04-SUMMARY.md`
</output>
