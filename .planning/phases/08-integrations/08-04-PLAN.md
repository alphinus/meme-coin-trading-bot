---
phase: 08-integrations
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - server/src/integrations/google/calendar.ts
  - server/src/routes/calendar.ts
autonomous: true

must_haves:
  truths:
    - "Google Calendar events are polled periodically and new/changed events are detected"
    - "Calendar meetings are matched to projects by AI analyzing meeting title and description against project names"
    - "Post-meeting prompts are generated automatically when a meeting's end time has passed"
    - "Users can view calendar events linked to a specific project"
  artifacts:
    - path: "server/src/integrations/google/calendar.ts"
      provides: "Calendar polling with syncToken, meeting-to-project linking, post-meeting prompt generation"
      exports: ["pollCalendar", "startCalendarPolling", "stopCalendarPolling", "getLinkedMeetings"]
    - path: "server/src/routes/calendar.ts"
      provides: "REST API for calendar management, linked meetings, polling control"
      exports: ["default (Router)"]
  key_links:
    - from: "server/src/integrations/google/calendar.ts"
      to: "server/src/integrations/google/auth.ts"
      via: "getOAuth2Client() for Calendar API access"
      pattern: "getOAuth2Client"
    - from: "server/src/integrations/google/calendar.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse for meeting-to-project matching"
      pattern: "generateAiResponse"
    - from: "server/src/integrations/google/calendar.ts"
      to: "server/src/notifications/emitter.ts"
      via: "emitNotificationForEvent for post-meeting prompts"
      pattern: "emitNotificationForEvent"
---

<objective>
Implement Google Calendar integration: periodic polling for calendar events, AI-powered meeting-to-project linking, and automatic post-meeting prompt generation -- covering requirement INTG-02.

Purpose: Google Calendar meetings are linked to projects so users see relevant meetings in project context. After meetings end, the system prompts users to document outcomes.
Output: Calendar polling module with syncToken tracking, AI meeting matcher, post-meeting prompt emitter, calendar REST routes.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integrations/08-RESEARCH.md
@.planning/phases/08-integrations/08-01-SUMMARY.md
@server/src/integrations/google/auth.ts
@server/src/ai/generate.ts
@server/src/events/store.ts
@server/src/notifications/emitter.ts
@server/src/events/reducers/project.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Calendar polling, AI meeting-project matching, and post-meeting prompts</name>
  <files>
    server/src/integrations/google/calendar.ts
  </files>
  <action>
Create `server/src/integrations/google/calendar.ts`:

1. Imports: google from "googleapis", getOAuth2Client from "./auth.js", appendEvent/readEvents from "../../events/store.js", generateAiResponse from "../../ai/generate.js", getAllProjects from "../../events/reducers/project.js", emitNotificationForEvent from "../../notifications/emitter.js", randomUUID from "crypto"

2. Module-level state:
   - let _pollingInterval: NodeJS.Timeout | null = null
   - let _processedEndTimes: Set<string> = new Set() (track which meetings already got post-meeting prompts to avoid duplicates)

3. `getCalendarSyncState()`: Read integration events for "integration" aggregateType, find latest integration.calendar_synced event, return { syncToken?: string, lastPollAt?: string }

4. `pollCalendar(userId: string)`:
   a. Get OAuth2 client (return early if null)
   b. Create calendar client: google.calendar({ version: "v3", auth: oauth2 })
   c. Get sync state
   d. List events:
      - If syncToken exists: calendar.events.list({ calendarId: "primary", syncToken })
      - If no syncToken (first poll): calendar.events.list({ calendarId: "primary", timeMin: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), maxResults: 50, singleEvents: true, orderBy: "startTime" })
   e. Handle 410 (sync token expired): Clear syncToken, re-poll without it
   f. For each event in response: emit integration.calendar_event_linked event with CalendarMeeting data { eventId, title: event.summary, description: event.description, start: event.start.dateTime || event.start.date, end: event.end.dateTime || event.end.date, attendees: event.attendees?.map(a => a.email) || [] }
   g. Save new syncToken: emit integration.calendar_synced event with { syncToken: response.data.nextSyncToken }
   h. After processing new events, run AI matching for unlinked meetings
   i. After processing, check for post-meeting prompts

5. `matchMeetingsToProjects(meetings: CalendarMeeting[], teamId: string, language: "de" | "en")`:
   a. Get all non-archived team projects
   b. For each unlinked meeting (no linkedProjectId), call generateAiResponse with a system prompt that matches meeting title/description to project names
   c. Use taskType: "email_routing" (reuse -- it's the same classification pattern, or use "search" which is also a matching task). Actually better: use a simple heuristic first (keyword match) and only fall back to AI for ambiguous cases. For 2 users, simple keyword matching of meeting title against project names is sufficient.
   d. Simple matching: for each meeting, check if any project name (or significant words from it) appears in the meeting title or description. If match confidence > 60%, link it.
   e. If linked, emit integration.calendar_event_linked event (update with linkedProjectId)

6. `checkPostMeetingPrompts(userId: string)`:
   a. Read recent calendar events from integration events (last 24 hours)
   b. For each event where end time has passed AND not in _processedEndTimes:
      - Add to _processedEndTimes
      - Emit a notification event. Create a synthetic DomainEvent for the notification: appendEvent({ type: "integration.calendar_event_linked", aggregateType: "integration", aggregateId: meeting.eventId, userId, correlationId: randomUUID(), version: 1, data: { ...meeting, promptType: "post_meeting", message: `Meeting "${meeting.title}" has ended. Document key outcomes and decisions.` } })
      - Fire-and-forget: emitNotificationForEvent on the created event (note: this requires adding "integration.calendar_event_linked" to the notification emitter's EVENT_NOTIFICATION_MAP -- do this in the same file by extending the emitter, OR handle it locally by calling dispatchNotification directly). Better approach: call dispatchNotification directly from this module for post-meeting prompts, since the emitter pattern expects domain events and this is a derived notification.
      - Import dispatchNotification from "../../notifications/dispatcher.js"
      - Call dispatchNotification({ userId, type: "integration.calendar_event_linked", priority: "medium", title: "Post-Meeting Prompt", body: `Meeting "${meeting.title}" has ended. Document key outcomes and action items.` })

7. `getLinkedMeetings(projectId?: string)`: Read integration.calendar_event_linked events, reduce to CalendarMeeting[] with linked projects. If projectId provided, filter to only that project's meetings.

8. `startCalendarPolling(userId: string)`: setInterval every 300_000ms (5 minutes). Store handle.
9. `stopCalendarPolling()`: clearInterval.

Export: pollCalendar, startCalendarPolling, stopCalendarPolling, getLinkedMeetings, matchMeetingsToProjects
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "pollCalendar" in calendar.ts.
    Grep for "checkPostMeetingPrompts" in calendar.ts.
    Grep for "getLinkedMeetings" in calendar.ts.
  </verify>
  <done>
    Calendar polling uses syncToken for incremental sync every 5 minutes. Meetings are matched to projects via keyword matching. Post-meeting prompts are dispatched as notifications when meeting end time passes. All functions exported and TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Calendar REST routes</name>
  <files>
    server/src/routes/calendar.ts
  </files>
  <action>
Create `server/src/routes/calendar.ts`:
   - Express Router with routes:

   **Polling control:**
   - POST /start-polling: Start calendar polling for authenticated user. Call startCalendarPolling(req.session.userId). Return 200 { status: "polling_started" }.
   - POST /stop-polling: Stop calendar polling. Call stopCalendarPolling(). Return 200 { status: "polling_stopped" }.
   - POST /sync-now: Trigger an immediate poll. Call pollCalendar(req.session.userId). Return 200 { status: "sync_complete" }.

   **Meeting management:**
   - GET /meetings: Return all calendar meetings from getLinkedMeetings(). Accept optional ?projectId query param to filter by project.
   - GET /meetings/upcoming: Return meetings where start > now, sorted by start time ascending. Limit to next 10.
   - POST /meetings/:eventId/link: Accept { projectId }. Manually link a meeting to a project by emitting integration.calendar_event_linked event with linkedProjectId. Return 200.
   - POST /meetings/:eventId/unlink: Remove project link from a meeting by emitting a new integration.calendar_event_linked event with linkedProjectId: null. Return 200.

   All routes use requireAuth (applied at mount level).
   Export default router.
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "start-polling" in calendar.ts routes file.
    Grep for "meetings" in calendar.ts routes file.
    Verify router is exported as default.
  </verify>
  <done>
    Calendar routes provide polling control (start/stop/sync-now), meeting listing with project filtering, upcoming meetings endpoint, and manual meeting-project linking/unlinking. INTG-02 API complete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Calendar polling uses syncToken for incremental sync (not full re-fetch)
- Meetings matched to projects via keyword analysis
- Post-meeting prompts dispatched as notifications when meeting ends
- Calendar routes provide CRUD for meeting-project links
- Polling interval: 5 minutes (300_000ms)
</verification>

<success_criteria>
INTG-02: Google Calendar meetings are polled every 5 minutes, linked to projects via keyword matching, and post-meeting prompts appear automatically as notifications when meetings end. Users can view meetings per project and manually link/unlink meetings.
</success_criteria>

<output>
After completion, create `.planning/phases/08-integrations/08-04-SUMMARY.md`
</output>
