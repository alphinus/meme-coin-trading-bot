---
phase: 08-integrations
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - server/src/integrations/google/calendar.ts
  - server/src/routes/calendar.ts
  - server/src/notifications/emitter.ts
autonomous: true

must_haves:
  truths:
    - "User can view calendar meetings linked to their projects"
    - "User receives post-meeting prompts automatically after a meeting ends"
    - "Meetings are matched to projects by analyzing meeting titles against project names"
    - "User can manually link or unlink a meeting to a project"
  artifacts:
    - path: "server/src/integrations/google/calendar.ts"
      provides: "Calendar polling with syncToken, meeting-to-project linking, post-meeting prompt generation"
      exports: ["pollCalendar", "startCalendarPolling", "stopCalendarPolling", "getLinkedMeetings"]
    - path: "server/src/routes/calendar.ts"
      provides: "REST API for calendar management, linked meetings, polling control"
      exports: ["default (Router)"]
    - path: "server/src/notifications/emitter.ts"
      provides: "Updated EVENT_NOTIFICATION_MAP with integration.calendar_event_linked entry for post-meeting prompts"
  key_links:
    - from: "server/src/integrations/google/calendar.ts"
      to: "server/src/integrations/google/auth.ts"
      via: "getOAuth2Client() for Calendar API access"
      pattern: "getOAuth2Client"
    - from: "server/src/integrations/google/calendar.ts"
      to: "server/src/notifications/emitter.ts"
      via: "emitNotificationForEvent for post-meeting prompts using calendar_event_linked mapping"
      pattern: "emitNotificationForEvent"
    - from: "server/src/notifications/emitter.ts"
      to: "EVENT_NOTIFICATION_MAP"
      via: "integration.calendar_event_linked entry with promptType-aware body"
      pattern: "integration\\.calendar_event_linked"
---

<objective>
Implement Google Calendar integration: periodic polling for calendar events, AI-powered meeting-to-project linking, and automatic post-meeting prompt generation -- covering requirement INTG-02.

Purpose: Google Calendar meetings are linked to projects so users see relevant meetings in project context. After meetings end, the system prompts users to document outcomes.
Output: Calendar polling module with syncToken tracking, AI meeting matcher, post-meeting prompt emitter, calendar REST routes, updated notification emitter map.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integrations/08-RESEARCH.md
@.planning/phases/08-integrations/08-01-SUMMARY.md
@server/src/integrations/google/auth.ts
@server/src/ai/generate.ts
@server/src/events/store.ts
@server/src/notifications/emitter.ts
@server/src/events/reducers/project.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Calendar polling, meeting-project matching, post-meeting prompts, and notification emitter wiring</name>
  <files>
    server/src/integrations/google/calendar.ts
    server/src/notifications/emitter.ts
  </files>
  <action>
**First: Update the notification emitter to recognize calendar post-meeting events.**

0. Update `server/src/notifications/emitter.ts`:
   - Add a new entry to EVENT_NOTIFICATION_MAP for post-meeting prompts:
     ```
     "integration.calendar_event_linked": {
       priority: "medium",
       title: "Post-Meeting Prompt",
       body: (data) => data.promptType === "post_meeting"
         ? `Meeting "${data.title ?? "meeting"}" has ended. Document key outcomes and action items.`
         : `Calendar event "${data.title ?? "event"}" linked to project.`,
     },
     ```
   - Also add an entry for email received notifications:
     ```
     "integration.email_received": {
       priority: "low",
       title: "New Email",
       body: (data) => `Email from ${data.from ?? "unknown"}: "${data.subject ?? "no subject"}"`,
     },
     ```
   - Also add an entry for email sent notifications:
     ```
     "integration.email_sent": {
       priority: "medium",
       title: "Email Sent",
       body: (data) => `Email draft sent successfully.`,
     },
     ```
   - These entries enable the existing emitNotificationForEvent fire-and-forget pattern to handle integration events without needing to call dispatchNotification directly.

**Then: Create the calendar module.**

Create `server/src/integrations/google/calendar.ts`:

1. Imports: google from "googleapis", getOAuth2Client from "./auth.js", appendEvent/readEvents from "../../events/store.js", getAllProjects from "../../events/reducers/project.js", emitNotificationForEvent from "../../notifications/emitter.js", randomUUID from "crypto"

2. Module-level state:
   - let _pollingInterval: NodeJS.Timeout | null = null
   - let _processedEndTimes: Set<string> = new Set() (track which meetings already got post-meeting prompts to avoid duplicates)

3. `getCalendarSyncState()`: Read integration events for "integration" aggregateType, find latest integration.calendar_synced event, return { syncToken?: string, lastPollAt?: string }

4. `pollCalendar(userId: string)`:
   a. Get OAuth2 client (return early if null)
   b. Create calendar client: google.calendar({ version: "v3", auth: oauth2 })
   c. Get sync state
   d. List events:
      - If syncToken exists: calendar.events.list({ calendarId: "primary", syncToken })
      - If no syncToken (first poll): calendar.events.list({ calendarId: "primary", timeMin: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), maxResults: 50, singleEvents: true, orderBy: "startTime" })
   e. Handle 410 (sync token expired): Clear syncToken, re-poll without it
   f. For each event in response: emit integration.calendar_event_linked event with CalendarMeeting data { eventId, title: event.summary, description: event.description, start: event.start.dateTime || event.start.date, end: event.end.dateTime || event.end.date, attendees: event.attendees?.map(a => a.email) || [] }
   g. Save new syncToken: emit integration.calendar_synced event with { syncToken: response.data.nextSyncToken }
   h. After processing new events, run matching for unlinked meetings
   i. After processing, check for post-meeting prompts

5. `matchMeetingsToProjects(meetings: CalendarMeeting[])`:
   a. Get all non-archived projects
   b. For each unlinked meeting (no linkedProjectId), check if any project name (or significant words from it) appears in the meeting title or description. If match, link it.
   c. Simple keyword matching: for each meeting, for each project, check if project.name words (split by space, filter words >3 chars) appear in meeting.title.toLowerCase() or meeting.description?.toLowerCase(). If match found, emit integration.calendar_event_linked event with linkedProjectId set.

6. `checkPostMeetingPrompts(userId: string)`:
   a. Read recent calendar events from integration events (last 24 hours)
   b. For each event where end time has passed AND not in _processedEndTimes:
      - Add eventId to _processedEndTimes
      - Create a DomainEvent for the post-meeting prompt: appendEvent({ type: "integration.calendar_event_linked", aggregateType: "integration", aggregateId: meeting.eventId, userId, correlationId: randomUUID(), version: 1, data: { ...meeting, promptType: "post_meeting" } })
      - Fire-and-forget: emitNotificationForEvent on the created event. This now works because "integration.calendar_event_linked" is in EVENT_NOTIFICATION_MAP (added in step 0) and the body function checks for promptType === "post_meeting".

7. `getLinkedMeetings(projectId?: string)`: Read integration.calendar_event_linked events, reduce to CalendarMeeting[] with linked projects. If projectId provided, filter to only that project's meetings.

8. `startCalendarPolling(userId: string)`: setInterval every 300_000ms (5 minutes). Store handle.
9. `stopCalendarPolling()`: clearInterval.

Export: pollCalendar, startCalendarPolling, stopCalendarPolling, getLinkedMeetings, matchMeetingsToProjects
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "integration.calendar_event_linked" in emitter.ts to confirm notification map entry exists.
    Grep for "post_meeting" in emitter.ts to confirm post-meeting prompt body is handled.
    Grep for "pollCalendar" in calendar.ts.
    Grep for "checkPostMeetingPrompts" in calendar.ts.
    Grep for "emitNotificationForEvent" in calendar.ts to confirm proper notification wiring.
    Grep for "getLinkedMeetings" in calendar.ts.
  </verify>
  <done>
    Notification emitter updated with integration.calendar_event_linked, integration.email_received, and integration.email_sent entries. Calendar polling uses syncToken for incremental sync every 5 minutes. Meetings are matched to projects via keyword matching. Post-meeting prompts use the standard emitNotificationForEvent pattern (not direct dispatchNotification calls). All functions exported and TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Calendar REST routes</name>
  <files>
    server/src/routes/calendar.ts
  </files>
  <action>
Create `server/src/routes/calendar.ts`:
   - Express Router with routes:

   **Polling control:**
   - POST /start-polling: Start calendar polling for authenticated user. Call startCalendarPolling(req.session.userId). Return 200 { status: "polling_started" }.
   - POST /stop-polling: Stop calendar polling. Call stopCalendarPolling(). Return 200 { status: "polling_stopped" }.
   - POST /sync-now: Trigger an immediate poll. Call pollCalendar(req.session.userId). Return 200 { status: "sync_complete" }.

   **Meeting management:**
   - GET /meetings: Return all calendar meetings from getLinkedMeetings(). Accept optional ?projectId query param to filter by project.
   - GET /meetings/upcoming: Return meetings where start > now, sorted by start time ascending. Limit to next 10.
   - POST /meetings/:eventId/link: Accept { projectId }. Manually link a meeting to a project by emitting integration.calendar_event_linked event with linkedProjectId. Return 200.
   - POST /meetings/:eventId/unlink: Remove project link from a meeting by emitting a new integration.calendar_event_linked event with linkedProjectId: null. Return 200.

   All routes use requireAuth (applied at mount level).
   Export default router.
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "start-polling" in calendar.ts routes file.
    Grep for "meetings" in calendar.ts routes file.
    Verify router is exported as default.
  </verify>
  <done>
    Calendar routes provide polling control (start/stop/sync-now), meeting listing with project filtering, upcoming meetings endpoint, and manual meeting-project linking/unlinking. INTG-02 API complete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Calendar polling uses syncToken for incremental sync (not full re-fetch)
- Meetings matched to projects via keyword analysis
- Post-meeting prompts dispatched via emitNotificationForEvent using the EVENT_NOTIFICATION_MAP entry for "integration.calendar_event_linked" with promptType-aware body
- Notification emitter.ts has entries for integration.calendar_event_linked, integration.email_received, and integration.email_sent
- Calendar routes provide CRUD for meeting-project links
- Polling interval: 5 minutes (300_000ms)
</verification>

<success_criteria>
INTG-02: Google Calendar meetings are polled every 5 minutes, linked to projects via keyword matching, and post-meeting prompts appear automatically as notifications when meetings end (using the standard emitNotificationForEvent pattern). Users can view meetings per project and manually link/unlink meetings.
</success_criteria>

<output>
After completion, create `.planning/phases/08-integrations/08-04-SUMMARY.md`
</output>
