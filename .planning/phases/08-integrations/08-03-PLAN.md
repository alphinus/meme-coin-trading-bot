---
phase: 08-integrations
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - server/src/integrations/github/repos.ts
  - server/src/integrations/github/webhooks.ts
  - server/src/integrations/github/fork.ts
  - server/src/routes/github-integration.ts
autonomous: true

must_haves:
  truths:
    - "GitHub commits and PRs for a linked repo are fetched and stored as integration events"
    - "GitHub webhooks are verified and processed to detect new commits and PRs"
    - "User can input a GitHub URL to fork a repo, and AI analyzes the code producing an idea pool entry"
    - "Repos can be linked to projects, and linked activity is queryable"
  artifacts:
    - path: "server/src/integrations/github/repos.ts"
      provides: "GitHub repo operations: list commits, list PRs, link repo to project"
      exports: ["listRepoCommits", "listRepoPullRequests", "linkRepoToProject", "getLinkedRepos"]
    - path: "server/src/integrations/github/webhooks.ts"
      provides: "GitHub webhook verification and event processing"
      exports: ["handleGitHubWebhook"]
    - path: "server/src/integrations/github/fork.ts"
      provides: "Fork workflow with async polling and AI code analysis"
      exports: ["forkAndAnalyze"]
    - path: "server/src/routes/github-integration.ts"
      provides: "REST API for GitHub repo linking, commits, PRs, fork, webhooks"
      exports: ["default (Router)"]
  key_links:
    - from: "server/src/integrations/github/repos.ts"
      to: "server/src/integrations/github/client.ts"
      via: "getOctokit() for API calls"
      pattern: "getOctokit"
    - from: "server/src/integrations/github/fork.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse with taskType code_analysis"
      pattern: "generateAiResponse.*code_analysis"
    - from: "server/src/integrations/github/fork.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for idea.created from code analysis"
      pattern: "appendEvent.*idea\\.created"
---

<objective>
Implement GitHub integration: repo linking to projects, commit/PR listing, webhook processing, and the fork-then-analyze workflow that feeds into the idea pool -- covering INTG-03 and INTG-04.

Purpose: GitHub activity (commits, PRs) is linked to projects for visibility. Users can fork external repos, and AI analyzes the code to create idea pool entries.
Output: GitHub repo operations module, webhook handler, fork + AI analysis module, GitHub integration REST routes.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integrations/08-RESEARCH.md
@.planning/phases/08-integrations/08-01-SUMMARY.md
@server/src/integrations/github/client.ts
@server/src/ai/generate.ts
@server/src/events/store.ts
@server/src/events/reducers/idea.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: GitHub repo operations and webhook handler</name>
  <files>
    server/src/integrations/github/repos.ts
    server/src/integrations/github/webhooks.ts
  </files>
  <action>
1. Create `server/src/integrations/github/repos.ts`:
   - Import { getOctokit } from "./client.js", { appendEvent, readEvents } from "../../events/store.js", { randomUUID } from "crypto"
   - Import GitHubRepoLink, GitHubCommitInfo, GitHubPRInfo from "shared/types/integration.js"

   Functions:
   - `linkRepoToProject(owner, repo, projectId, userId)`: Emit integration.github_commit_linked event with { owner, repo, projectId, linkedAt }. Actually use a "integration.github_connected" pattern -- no, use a custom approach: store a "repo_link" sub-event. Better: emit a specific event type. Since we don't have a "repo_linked" event type, reuse integration.github_commit_linked with a linkType flag, or simply store links as integration events with data.action = "link". Simplest: just emit an event with type "integration.github_connected" and data { owner, repo, projectId, action: "repo_linked" }. Wait -- we already have integration.github_connected. Let's keep it simple: store repo links as integration events and derive them from the reducer.
   - Actually, refine approach: The link is stored by emitting an event. Read it back by filtering. Use aggregateId = `${owner}/${repo}` so each repo's events are together.
   - `linkRepoToProject(owner: string, repo: string, projectId: string, userId: string)`: appendEvent({ type: "integration.github_commit_linked", aggregateType: "integration", aggregateId: `github:${owner}/${repo}`, userId, correlationId: randomUUID(), version: 1, data: { owner, repo, projectId, action: "repo_linked" } })
   - `getLinkedRepos(projectId?: string)`: Read all integration events, filter for github_commit_linked with data.action === "repo_linked", optionally filter by projectId. Return GitHubRepoLink[].
   - `listRepoCommits(owner, repo, options?)`: Use getOctokit().rest.repos.listCommits({ owner, repo, per_page: options?.perPage || 20, since: options?.since }). Map to GitHubCommitInfo[]. Emit integration.github_commit_linked events for each new commit (check if already linked by sha). Return the commits.
   - `listRepoPullRequests(owner, repo, state?)`: Use getOctokit().rest.pulls.list({ owner, repo, state: state || "open" }). Map to GitHubPRInfo[]. Emit integration.github_pr_linked events for each PR. Return the PRs.
   - Export all 4 functions.

2. Create `server/src/integrations/github/webhooks.ts`:
   - Import { Webhooks } from "@octokit/webhooks"
   - Import appendEvent from events/store, randomUUID from crypto
   - Create webhooks instance: new Webhooks({ secret: process.env.GITHUB_WEBHOOK_SECRET || "default-dev-secret" })
   - Register handlers:
     a. webhooks.on("push", ({ payload }) => { ... }): For each commit in payload.commits, emit integration.github_commit_linked event with { sha, message, author, date, repoOwner: payload.repository.owner.login, repoName: payload.repository.name }
     b. webhooks.on("pull_request", ({ payload }) => { ... }): Emit integration.github_pr_linked event with PR details (number, title, state, url, repoOwner, repoName)
   - `handleGitHubWebhook(req, res)`: Use webhooks.verifyAndReceive({ id: req.headers["x-github-delivery"], name: req.headers["x-github-event"], payload: req.body, signature: req.headers["x-hub-signature-256"] }). Return 200 on success, 401 on verification failure.
   - Export handleGitHubWebhook
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "listRepoCommits" in repos.ts.
    Grep for "handleGitHubWebhook" in webhooks.ts.
  </verify>
  <done>
    Repos can be linked to projects. Commits and PRs are fetched via Octokit and stored as integration events. Webhooks are verified via @octokit/webhooks and processed for push/PR events. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fork workflow with AI code analysis and GitHub integration routes</name>
  <files>
    server/src/integrations/github/fork.ts
    server/src/routes/github-integration.ts
  </files>
  <action>
1. Create `server/src/integrations/github/fork.ts`:
   - Import { getOctokit } from "./client.js", { generateAiResponse } from "../../ai/generate.js", { appendEvent } from "../../events/store.js", { randomUUID } from "crypto"
   - Import ForkResult from "shared/types/integration.js"

   `forkAndAnalyze(sourceUrl: string, userId: string, teamId: string, language: "de" | "en")`:
   a. Parse owner/repo from sourceUrl (handle https://github.com/owner/repo and github.com/owner/repo formats)
   b. Fork: const fork = await getOctokit().rest.repos.createFork({ owner, repo }). Emit integration.github_fork_created event.
   c. Poll for fork readiness: retry getOctokit().rest.repos.get({ owner: fork.data.owner.login, repo: fork.data.name }) up to 10 times with 3-second delays. Fork is ready when response status is 200 and response.data.size > 0.
   d. Fetch code context for AI analysis:
      - README: try getOctokit().rest.repos.getContent({ owner, repo, path: "README.md" }). Decode base64 content. If 404, use empty string.
      - File tree: getOctokit().rest.git.getTree({ owner, repo, tree_sha: "HEAD", recursive: "1" }). Take first 50 files, format as path list.
      - package.json (if exists): fetch and decode.
      - Cap total AI input at 8000 characters.
   e. AI analysis: call generateAiResponse({ taskType: "code_analysis", projectId: teamId, language, systemPrompt, userPrompt })
      - System prompt: "Analyze this GitHub repository. Provide: 1) What it does (1-2 sentences), 2) Key technologies used, 3) Potential use cases, 4) Quality assessment (code structure, documentation). Respond as JSON: { summary, technologies: string[], useCases: string[], qualityScore: 1-10, qualityNotes: string }"
      - User prompt: README + file tree + package.json
   f. Create idea from analysis: emit idea.created event with { title: `Fork: ${owner}/${repo}`, rawInput: AI analysis summary, source: "github_fork", sourceUrl, technologies, useCases }
   g. Emit integration.github_code_analyzed event with { owner, repo, forkUrl, analysisResult, ideaId }
   h. Return ForkResult with forkUrl, fullName, analysisStatus: "complete"
   i. Wrap in try/catch -- on failure, emit integration.github_code_analyzed with analysisStatus: "failed"

2. Create `server/src/routes/github-integration.ts`:
   - Express Router with routes:

   **Repo linking:**
   - POST /repos/link: Accept { owner, repo, projectId }. Call linkRepoToProject. Return 201.
   - GET /repos/linked: Accept optional ?projectId query param. Call getLinkedRepos(projectId). Return linked repos.

   **Commits and PRs (INTG-03):**
   - GET /repos/:owner/:repo/commits: Call listRepoCommits(owner, repo, { perPage: req.query.perPage, since: req.query.since }). Return GitHubCommitInfo[].
   - GET /repos/:owner/:repo/pulls: Call listRepoPullRequests(owner, repo, req.query.state). Return GitHubPRInfo[].

   **Fork and analyze (INTG-04):**
   - POST /fork: Accept { sourceUrl }. Call forkAndAnalyze(sourceUrl, userId, teamId, language) in fire-and-forget pattern. Return 202 { status: "forking", message: "Fork initiated, analysis in progress" }. The fork+analysis runs in background; client polls for status.
   - GET /fork/status/:ideaId: Check if idea.created event exists for the given ideaId (from code analysis). Return { status: "pending" | "complete" | "failed" }.

   **Webhooks:**
   - POST /webhooks: Delegates to handleGitHubWebhook(req, res). This route does NOT use requireAuth (webhooks come from GitHub). Note: must be mounted separately from the auth-protected routes, or use a middleware bypass.

   - Export default router
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "forkAndAnalyze" in fork.ts.
    Grep for "/repos/link" in github-integration.ts.
    Grep for "/fork" in github-integration.ts.
    Grep for "/webhooks" in github-integration.ts.
  </verify>
  <done>
    Fork workflow: parse GitHub URL, fork repo, poll for readiness, fetch README + file tree, AI analyzes code, creates idea pool entry. GitHub integration routes expose repo linking, commit/PR listing, fork initiation, and webhook endpoint. INTG-03 and INTG-04 complete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Commits and PRs fetched via Octokit and stored as integration events (INTG-03)
- Fork workflow: parse URL -> fork -> poll readiness -> AI code analysis -> idea.created event (INTG-04)
- GitHub webhooks verified and processed for push/PR events
- All routes accessible via REST API
- AI code analysis capped at 8000 characters input
</verification>

<success_criteria>
INTG-03: GitHub commits and PRs are linked to projects and queryable via API. INTG-04: User inputs a GitHub URL, the system forks the repo, AI analyzes the code (README + structure + package.json), and the analysis feeds into the idea pool as a new idea. Webhooks receive real-time push/PR notifications from GitHub.
</success_criteria>

<output>
After completion, create `.planning/phases/08-integrations/08-03-SUMMARY.md`
</output>
