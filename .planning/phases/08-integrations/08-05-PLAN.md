---
phase: 08-integrations
plan: 05
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - server/src/search/tools.ts
  - server/src/search/engine.ts
  - server/src/routes/search.ts
autonomous: true

must_haves:
  truths:
    - "User can ask natural-language questions and receive accurate AI-powered results"
    - "AI uses tool-calling to query projects, events, decisions, ideas, and soul documents"
    - "Search results reference only data returned by tools, not hallucinated content"
    - "Search queries and results are logged as events for audit trail"
  artifacts:
    - path: "server/src/search/tools.ts"
      provides: "Search tool definitions (search_projects, search_decisions, search_events, search_ideas) using AI SDK tool() function with Zod schemas"
      exports: ["searchTools"]
    - path: "server/src/search/engine.ts"
      provides: "AI search engine using generateText with tools"
      exports: ["aiSearch"]
    - path: "server/src/routes/search.ts"
      provides: "REST API for AI search"
      exports: ["default (Router)"]
  key_links:
    - from: "server/src/search/engine.ts"
      to: "server/src/search/tools.ts"
      via: "searchTools passed to generateText"
      pattern: "searchTools"
    - from: "server/src/search/engine.ts"
      to: "server/src/ai/providers.ts"
      via: "aiRegistry.languageModel for model selection"
      pattern: "aiRegistry\\.languageModel"
    - from: "server/src/search/tools.ts"
      to: "server/src/events/store.ts"
      via: "readAllEvents and readEvents for data access"
      pattern: "readAllEvents|readEvents"
---

<objective>
Implement AI-powered natural-language search using AI SDK tool-calling over the JSONL event store -- covering requirement SRCH-01.

Purpose: Users can ask questions like "show me all open decisions in Project X" and get accurate, AI-synthesized answers backed by real data from the event store.
Output: Search tool definitions, AI search engine with tool-calling, search REST route.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integrations/08-RESEARCH.md
@.planning/phases/08-integrations/08-01-SUMMARY.md
@server/src/events/store.ts
@server/src/events/reducers/project.ts
@server/src/events/reducers/idea.ts
@server/src/ai/providers.ts
@server/src/ai/generate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search tool definitions with Zod schemas</name>
  <files>
    server/src/search/tools.ts
  </files>
  <action>
Create `server/src/search/tools.ts`:

Import { tool } from "ai", { z } from "zod", { getAllProjects } from "../events/reducers/project.js", { readEvents, readAllEvents } from "../events/store.js"

Define and export `searchTools` object with these tools:

1. `search_projects`: tool({
   description: "Search for projects by name, description, status, phase, or team. Returns matching projects with their current state.",
   parameters: z.object({
     nameContains: z.string().optional().describe("Substring match on project name or description"),
     phase: z.string().optional().describe("Filter by current lifecycle phase (idea, research, planning, design, build, decision_point, execution, review_extraction)"),
     includeArchived: z.boolean().optional().default(false).describe("Include archived projects"),
   }),
   execute: async ({ nameContains, phase, includeArchived }) => {
     const projects = await getAllProjects();
     return projects
       .filter(p => {
         if (!includeArchived && p.archived) return false;
         if (nameContains && !p.name.toLowerCase().includes(nameContains.toLowerCase()) && !p.description?.toLowerCase().includes(nameContains.toLowerCase())) return false;
         if (phase && p.currentPhase !== phase) return false;
         return true;
       })
       .map(p => ({ id: p.id, name: p.name, phase: p.currentPhase, description: p.description?.slice(0, 200), archived: p.archived, memberCount: p.members.length, kpiCount: p.roiKpis.length }));
   }
})

2. `search_decisions`: tool({
   description: "Find decisions, phase transitions, KPI entries, and key milestones for a specific project. Use this when the user asks about decisions, progress, or milestones.",
   parameters: z.object({
     projectId: z.string().optional().describe("Project ID to search within"),
     projectName: z.string().optional().describe("Project name to search by (will be resolved to ID)"),
   }),
   execute: async ({ projectId, projectName }) => {
     if (!projectId && projectName) {
       const projects = await getAllProjects();
       const match = projects.find(p => p.name.toLowerCase().includes(projectName.toLowerCase()));
       projectId = match?.id;
     }
     if (!projectId) return { error: "No matching project found" };
     const events = await readEvents("project", projectId);
     return events
       .filter(e => ["project.phase_completed", "project.phase_advanced", "project.roi_kpi_added", "project.updated", "project.archived"].includes(e.type))
       .map(e => ({ type: e.type, timestamp: e.timestamp, data: e.data }))
       .slice(-30); // Last 30 decision events
   }
})

3. `search_events`: tool({
   description: "Search domain events across the system by type, aggregate, user, or date range. Use for broad queries about system activity.",
   parameters: z.object({
     eventType: z.string().optional().describe("Event type prefix to filter (e.g., 'project.', 'ai.', 'idea.')"),
     aggregateType: z.string().optional().describe("Aggregate type (project, team, idea, workflow, ai_member, integration, etc.)"),
     since: z.string().optional().describe("ISO date string -- only events after this date"),
     limit: z.number().optional().default(20).describe("Maximum number of results (default 20, max 50)"),
   }),
   execute: async ({ eventType, aggregateType, since, limit }) => {
     const cappedLimit = Math.min(limit || 20, 50);
     let events = await readAllEvents({ aggregateType, since, limit: cappedLimit * 2 }); // Fetch extra for type filtering
     if (eventType) {
       events = events.filter(e => e.type.startsWith(eventType));
     }
     return events.slice(0, cappedLimit).map(e => ({
       type: e.type, timestamp: e.timestamp, aggregateType: e.aggregateType,
       aggregateId: e.aggregateId, data: e.data
     }));
   }
})

4. `search_ideas`: tool({
   description: "Search ideas in the Idea Pool by title, status, or readiness score. Use when user asks about ideas, the idea pool, or pre-project concepts.",
   parameters: z.object({
     titleContains: z.string().optional().describe("Substring match on idea title or raw input"),
     status: z.string().optional().describe("Filter by status: active, graduated, archived"),
     minReadiness: z.number().optional().describe("Minimum readiness score (0-100)"),
   }),
   execute: async ({ titleContains, status, minReadiness }) => {
     const events = await readEvents("idea");
     // Group by aggregateId and reduce to latest state (simple: collect created events and latest status)
     const ideaMap = new Map<string, any>();
     for (const e of events) {
       if (e.type === "idea.created") {
         ideaMap.set(e.aggregateId, { id: e.aggregateId, title: e.data.title, rawInput: (e.data.rawInput as string)?.slice(0, 200), status: "active", readinessScore: 0, createdAt: e.timestamp });
       }
       if (e.type === "idea.readiness_assessed" && ideaMap.has(e.aggregateId)) {
         ideaMap.get(e.aggregateId).readinessScore = e.data.score;
       }
       if (e.type === "idea.graduated" && ideaMap.has(e.aggregateId)) {
         ideaMap.get(e.aggregateId).status = "graduated";
       }
       if (e.type === "idea.archived" && ideaMap.has(e.aggregateId)) {
         ideaMap.get(e.aggregateId).status = "archived";
       }
     }
     let ideas = Array.from(ideaMap.values());
     if (titleContains) {
       ideas = ideas.filter(i => i.title?.toLowerCase().includes(titleContains.toLowerCase()) || i.rawInput?.toLowerCase().includes(titleContains.toLowerCase()));
     }
     if (status) {
       ideas = ideas.filter(i => i.status === status);
     }
     if (minReadiness !== undefined) {
       ideas = ideas.filter(i => i.readinessScore >= minReadiness);
     }
     return ideas;
   }
})

Note: Use `parameters` (not `inputSchema`) as the property name -- this is the correct AI SDK v4+ convention for tool(). Double-check the AI SDK docs: in recent versions, `tool()` uses `parameters` with a Zod schema. If the codebase AI SDK uses `inputSchema`, follow that convention instead. Check `node_modules/ai/dist/index.d.ts` for the correct property name before implementing.
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "search_projects" in tools.ts.
    Grep for "search_decisions" in tools.ts.
    Grep for "search_events" in tools.ts.
    Grep for "search_ideas" in tools.ts.
    Verify searchTools object exports all 4 tools.
  </verify>
  <done>
    Four search tools defined with Zod schemas: search_projects (name/phase/archived), search_decisions (project decisions and milestones), search_events (broad event search), search_ideas (idea pool search). Each tool queries the JSONL event store via existing reducers and readEvents. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: AI search engine and search REST route</name>
  <files>
    server/src/search/engine.ts
    server/src/routes/search.ts
  </files>
  <action>
1. Create `server/src/search/engine.ts`:
   - Import { generateText } from "ai", { aiRegistry } from "../ai/providers.js", { searchTools } from "./tools.js", { appendEvent } from "../events/store.js", { randomUUID } from "crypto"
   - Import SearchResult from "shared/types/integration.js", { recordAiCost } from "../ai/cost/tracker.js"

   `aiSearch(query: string, teamId: string, language: "de" | "en")`: Promise<SearchResult>
   a. Get model: aiRegistry.languageModel("anthropic:balanced") (use the "search" task type mapping)
   b. Build system prompt:
      "You are a search assistant for a project management platform called Eluma. Answer the user's question by using the provided search tools to find relevant data. Rules: 1) ALWAYS use tools to find data before answering. 2) ONLY report information returned by the tools. NEVER invent or hallucinate data. 3) If no relevant data is found, say so clearly. 4) Be concise and factual. 5) Reference specific project names, dates, and details from tool results."
      Append language instruction: language === "de" ? "Antworte auf Deutsch." : "Respond in English."
   c. Call generateText({ model, tools: searchTools, maxSteps: 5, system: systemPrompt, prompt: query })
      - Note: Check AI SDK docs for the correct way to enable multi-step tool use. In AI SDK v4+, use `maxSteps` (not `stopWhen`). The research example uses `stopWhen: stepCountIs(5)` but this may be outdated -- check actual AI SDK API. If `maxSteps` is the correct parameter, use that.
   d. Extract answer from result.text
   e. Extract sources from tool calls: result.steps.flatMap(s => s.toolCalls || []).map(tc => `${tc.toolName}(${JSON.stringify(tc.args)})`)
   f. Record AI cost via recordAiCost (same pattern as generate.ts)
   g. Emit search.query_executed event: appendEvent({ type: "search.query_executed", aggregateType: "search", aggregateId: randomUUID(), userId: "system", correlationId: randomUUID(), version: 1, data: { query, answer: result.text.slice(0, 500), toolCallCount: sources.length, language } })
   h. Return { answer: result.text, sources, executedAt: new Date().toISOString() }
   i. Wrap in try/catch -- on error, return { answer: "Search failed: " + error.message, sources: [], executedAt: new Date().toISOString() }

   Export: aiSearch

2. Create `server/src/routes/search.ts`:
   - Express Router:
   - POST /query: Accept { query, language? } in body.
     a. Validate query is non-empty string, max 500 characters
     b. Resolve teamId from authenticated user's session (use getTeamForUser from team reducer)
     c. Default language to "en" if not provided
     d. Call aiSearch(query, teamId, language)
     e. Return 200 with SearchResult
   - GET /history: Read recent search.query_executed events (last 20), return as array
   - Export default router
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "aiSearch" in engine.ts.
    Grep for "maxSteps" in engine.ts (verify multi-step tool use is configured).
    Grep for "/query" in search.ts route.
    Grep for "/history" in search.ts route.
  </verify>
  <done>
    AI search engine uses generateText with tool-calling to query the event store. LLM decides which tools to call, tools execute queries against JSONL data, LLM synthesizes results. Search queries are logged as events. REST route provides /query and /history endpoints. SRCH-01 complete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- 4 search tools defined (projects, decisions, events, ideas) with Zod schemas
- AI search uses tool-calling with maxSteps: 5 for multi-step queries
- System prompt includes anti-hallucination instructions
- Search queries logged as search.query_executed events
- REST API: POST /query for search, GET /history for recent queries
</verification>

<success_criteria>
SRCH-01: User can ask natural-language questions like "show me all open decisions in Project X" and receive accurate AI-powered results. The AI uses structured tool-calling to query the event store (not hallucinate), and results are synthesized into human-readable answers. Search history is logged for audit trail.
</success_criteria>

<output>
After completion, create `.planning/phases/08-integrations/08-05-SUMMARY.md`
</output>
