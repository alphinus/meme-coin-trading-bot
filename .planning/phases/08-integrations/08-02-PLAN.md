---
phase: 08-integrations
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - server/src/integrations/google/gmail.ts
  - server/src/integrations/email/parser.ts
  - server/src/integrations/email/router.ts
  - server/src/integrations/email/drafter.ts
  - server/src/routes/integrations.ts
autonomous: true

must_haves:
  truths:
    - "Gmail inbox is polled periodically and new emails are detected via historyId tracking"
    - "Incoming emails are analyzed by AI and routed to the correct project with confidence scores"
    - "AI generates email draft replies that are stored as pending events for user review"
    - "Users can list pending drafts, approve them, and send via Gmail API"
  artifacts:
    - path: "server/src/integrations/google/gmail.ts"
      provides: "Gmail polling with historyId checkpoint, message fetching"
      exports: ["pollGmailInbox", "getGmailSyncState", "startGmailPolling", "stopGmailPolling"]
    - path: "server/src/integrations/email/router.ts"
      provides: "AI-powered email-to-project routing (mirrors voice routing pattern)"
      exports: ["analyzeEmailRouting"]
    - path: "server/src/integrations/email/drafter.ts"
      provides: "AI email draft generation and Gmail API send"
      exports: ["generateEmailDraft", "sendEmailDraft"]
    - path: "server/src/routes/integrations.ts"
      provides: "REST API for Google OAuth flow, email drafts, integration status"
      exports: ["default (Router)"]
  key_links:
    - from: "server/src/integrations/email/router.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse with taskType email_routing"
      pattern: "generateAiResponse.*email_routing"
    - from: "server/src/integrations/google/gmail.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for integration.email_received and integration.gmail_synced"
      pattern: "appendEvent.*integration\\.email"
    - from: "server/src/integrations/email/drafter.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse with taskType email_drafting"
      pattern: "generateAiResponse.*email_drafting"
---

<objective>
Implement Gmail polling, AI-powered email routing to projects, AI email draft generation, and email sending -- covering requirements INTG-01 and INTG-05.

Purpose: Users receive emails that the AI analyzes and routes to the correct project. The AI also prepares email draft replies that users can review and send from within the app.
Output: Gmail polling module, email parser, AI email router, AI email drafter, integration REST routes for OAuth flow and email management.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integrations/08-RESEARCH.md
@.planning/phases/08-integrations/08-01-SUMMARY.md
@server/src/voice/router-analysis.ts
@server/src/ai/generate.ts
@server/src/events/store.ts
@server/src/notifications/emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gmail polling, email parser, and AI email routing</name>
  <files>
    server/src/integrations/google/gmail.ts
    server/src/integrations/email/parser.ts
    server/src/integrations/email/router.ts
  </files>
  <action>
1. Create `server/src/integrations/email/parser.ts`:
   - Import `simpleParser` from "mailparser"
   - `parseEmailBody(rawPayload: any)`: Extract subject, from, to, text body, html body from Gmail API message payload. Gmail API returns base64url-encoded parts -- decode the text/plain and text/html parts. For multipart messages, walk the parts tree recursively. Use a simple base64url decode (Buffer.from(data, "base64url").toString("utf-8")) -- do NOT use mailparser for Gmail API responses (mailparser is for raw RFC822, Gmail API already parses structure). Instead, write a `extractGmailParts(payload)` helper that walks `payload.parts` recursively to find text/plain and text/html parts.
   - `extractHeaders(headers: Array<{name: string, value: string}>)`: Extract From, To, Subject, Date from Gmail header array into a clean object { from, to, subject, date }.
   - Export: parseEmailBody, extractHeaders

2. Create `server/src/integrations/google/gmail.ts`:
   - Import google from "googleapis", getOAuth2Client from "./auth.js", appendEvent/readEvents from events/store, randomUUID from crypto
   - `getGmailSyncState(userId: string)`: Read integration events, find latest integration.gmail_synced event, return { historyId, lastPollAt } or defaults { historyId: "", lastPollAt: "" }
   - `pollGmailInbox(userId: string)`: Follows the research pattern exactly:
     a. Get OAuth2 client (return early if null -- not connected)
     b. Create gmail client: google.gmail({ version: "v1", auth: oauth2 })
     c. Get sync state. If no historyId, do initial setup: call gmail.users.getProfile({userId: "me"}), store historyId via integration.gmail_synced event, return
     d. Poll: gmail.users.history.list({ userId: "me", startHistoryId, labelIds: ["INBOX"], historyTypes: ["messageAdded"] })
     e. For each new message: fetch with gmail.users.messages.get({ userId: "me", id, format: "metadata", metadataHeaders: ["From", "To", "Subject", "Date"] }). Then emit integration.email_received event with { messageId, threadId, from, to, subject, snippet, receivedAt }.
     f. Update historyId checkpoint via integration.gmail_synced event
     g. Wrap entire function in try/catch, log errors but do not throw (polling must be resilient)
   - `fetchFullMessage(messageId: string)`: Fetch full message body (format: "full") for AI analysis. Returns parsed { subject, from, to, body } using parser.
   - `startGmailPolling(userId: string)`: setInterval calling pollGmailInbox every 60_000ms (60 seconds). Store interval handle in module-level variable.
   - `stopGmailPolling()`: clearInterval on stored handle.
   - Use fire-and-forget pattern for AI routing after email receipt -- call analyzeEmailRouting and emit integration.email_routed event in the polling function after processing each new message.

3. Create `server/src/integrations/email/router.ts`:
   - Mirror the `analyzeVoiceRouting` pattern from `server/src/voice/router-analysis.ts` exactly:
     a. Import generateAiResponse from ai/generate.js, getAllProjects from events/reducers/project.js
     b. `analyzeEmailRouting(subject, body, sender, teamId, language)`:
        - Fetch team projects (non-archived), build project summary string
        - Call generateAiResponse with taskType: "email_routing" (cast to AiTaskType since we added it)
        - System prompt: classify email against existing projects, respond with JSON array
        - User prompt: project list + email details (from, subject, body truncated to 2000 chars)
        - Parse JSON response, validate structure, clamp confidence, sort by confidence desc
        - Return EmailRoutingSuggestion[] (from shared/types/integration.ts)
     c. Fallback: on AI error, use keyword matching against project names (same pattern as voice router)
   - Export: analyzeEmailRouting
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "analyzeEmailRouting" in router.ts to confirm function exists.
    Grep for "pollGmailInbox" in gmail.ts to confirm function exists.
    Grep for "extractHeaders" in parser.ts to confirm function exists.
  </verify>
  <done>
    Gmail polling fetches new messages via historyId tracking and emits integration.email_received events. Email parser extracts structured data from Gmail API responses. AI email router classifies emails to projects using the same pattern as voice routing. All TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: AI email drafter, email sending, and integration REST routes</name>
  <files>
    server/src/integrations/email/drafter.ts
    server/src/routes/integrations.ts
  </files>
  <action>
1. Create `server/src/integrations/email/drafter.ts`:
   - Import generateAiResponse from ai/generate.js, appendEvent from events/store.js, google from "googleapis", getOAuth2Client from google/auth.js, randomUUID from crypto
   - `generateEmailDraft(options)`: Generate an AI email draft reply:
     a. Accept { originalSubject, originalBody, originalSender, projectContext, teamId, language }
     b. Call generateAiResponse with taskType: "email_drafting"
     c. System prompt: "Generate a professional email reply. Include subject line (prefixed with Re:) and body. Respond as JSON: { subject, body }"
     d. User prompt: original email details + project context
     e. Parse JSON response
     f. Emit integration.email_draft_created event with { draftId: randomUUID(), to: [originalSender], subject, body, status: "pending", projectId, triggerEventId }
     g. Return the draft object
   - `sendEmailDraft(draftId: string, userId: string)`: Send an approved draft via Gmail API:
     a. Read integration events to find the draft (integration.email_draft_created with matching draftId in data)
     b. Get OAuth2 client, create gmail client
     c. Build RFC822 message string (To, Subject, From, Content-Type headers + body). Use Buffer.from(rawMessage).toString("base64url") for encoding.
     d. Call gmail.users.messages.send({ userId: "me", requestBody: { raw: encodedMessage } })
     e. Emit integration.email_sent event with { draftId, messageId: response.data.id, sentAt }
     f. Return success
   - `getDraftById(draftId: string)`: Read integration events, reconstruct draft state (created -> updated -> sent/rejected)
   - `getAllPendingDrafts()`: Read all integration events, filter to drafts with status "pending"
   - Export: generateEmailDraft, sendEmailDraft, getDraftById, getAllPendingDrafts

2. Create `server/src/routes/integrations.ts`:
   - Express Router with routes:

   **Google OAuth flow:**
   - GET /google/auth-url: Return the Google OAuth authorization URL (from getAuthUrl())
   - GET /google/callback: Exchange authorization code for tokens (from exchangeCode(req.query.code)), emit integration.google_connected event, redirect to /integrations page
   - POST /google/disconnect: Clear stored tokens (delete TOKENS_FILE), emit integration.google_disconnected event

   **Integration status:**
   - GET /status: Return IntegrationState from getIntegrationState() + isGoogleConnected() + isGitHubConnected() for real-time check

   **Gmail polling control:**
   - POST /gmail/start-polling: Start Gmail polling for the authenticated user (call startGmailPolling(userId)). Return 200.
   - POST /gmail/stop-polling: Stop Gmail polling. Return 200.

   **Email management:**
   - GET /emails/recent: Read last 20 integration.email_received events, return as EmailMessage[]
   - GET /emails/:messageId/route: Fetch full message, run AI routing analysis, return EmailRoutingSuggestion[]
   - POST /emails/:messageId/route: Accept { projectId } to manually route an email -- emit integration.email_routed event

   **Email drafts (INTG-05):**
   - GET /emails/drafts: Return all pending drafts from getAllPendingDrafts()
   - POST /emails/drafts/generate: Accept { messageId, projectId } -- fetch full message, generate AI draft reply
   - POST /emails/drafts/:draftId/send: Approve and send draft via sendEmailDraft()
   - POST /emails/drafts/:draftId/reject: Emit integration.email_draft_updated event with status: "rejected"

   - All routes use requireAuth middleware (applied at mount level in app.ts)
   - Fire-and-forget: emitNotificationForEvent for email_received and email_sent events
   - Export default router
  </action>
  <verify>
    Run `cd /Users/developer/eluma && npx tsc --noEmit` -- zero errors.
    Grep for "google/auth-url" in integrations.ts to confirm OAuth routes exist.
    Grep for "emails/drafts" in integrations.ts to confirm draft routes exist.
    Verify drafter.ts exports generateEmailDraft, sendEmailDraft, getDraftById, getAllPendingDrafts.
  </verify>
  <done>
    AI generates email draft replies stored as pending events. Users can list, approve, and send drafts via Gmail API. Integration routes provide OAuth flow, status check, polling control, email listing, routing, and draft management. All TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Gmail polling module handles historyId-based incremental sync
- AI email routing mirrors voice routing pattern (analyzeVoiceRouting -> analyzeEmailRouting)
- AI email drafting generates replies and stores as pending events
- Email sending uses Gmail API users.messages.send (not SMTP)
- Integration routes cover: OAuth flow (GET auth-url, GET callback, POST disconnect), status, polling, emails, drafts
- OAuth tokens stored in DATA_DIR/credentials/ (NOT in event store)
</verification>

<success_criteria>
INTG-01: Emails received via Gmail polling are analyzed by AI and routed to projects with confidence scores. INTG-05: AI prepares email drafts that users can review (GET drafts), approve, and send (POST drafts/:id/send) from within the app. All email functionality accessible via REST API.
</success_criteria>

<output>
After completion, create `.planning/phases/08-integrations/08-02-SUMMARY.md`
</output>
