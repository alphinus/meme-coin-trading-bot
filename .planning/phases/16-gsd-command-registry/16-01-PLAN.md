---
phase: 16-gsd-command-registry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/gsd.ts
  - server/src/gsd/types.ts
  - server/src/gsd/registry.ts
  - server/src/gsd/state-filter.ts
  - server/src/routes/gsd.ts
  - server/src/app.ts
  - gsd-plugin/commands/plan-phase.md
  - gsd-plugin/commands/research-phase.md
  - gsd-plugin/commands/analyze-code.md
  - gsd-plugin/commands/review-progress.md
  - gsd-plugin/commands/advance-phase.md
  - gsd-plugin/commands/generate-docs.md
autonomous: true

must_haves:
  truths:
    - "Server reads GSD commands from markdown files in gsd-plugin/commands/ directory at startup"
    - "GET /api/gsd/commands/:projectId returns filtered commands based on project state"
    - "Registry auto-refreshes when command files are added, changed, or removed"
    - "Commands that don't match the current project state are excluded from the API response"
  artifacts:
    - path: "shared/types/gsd.ts"
      provides: "GsdCommand and GsdCommandRegistry shared types"
      contains: "GsdCommand"
    - path: "server/src/gsd/registry.ts"
      provides: "Command registry singleton with file watching"
      exports: ["loadRegistry", "getRegistry"]
    - path: "server/src/gsd/state-filter.ts"
      provides: "State-based command filtering"
      exports: ["filterCommands"]
    - path: "server/src/routes/gsd.ts"
      provides: "GSD API endpoints"
      contains: "router.get"
    - path: "gsd-plugin/commands/plan-phase.md"
      provides: "Plan Phase command definition"
      contains: "label:"
  key_links:
    - from: "server/src/routes/gsd.ts"
      to: "server/src/gsd/registry.ts"
      via: "getRegistry() import"
      pattern: "getRegistry"
    - from: "server/src/routes/gsd.ts"
      to: "server/src/gsd/state-filter.ts"
      via: "filterCommands() import"
      pattern: "filterCommands"
    - from: "server/src/app.ts"
      to: "server/src/routes/gsd.ts"
      via: "app.use(/api/gsd)"
      pattern: "api/gsd"
---

<objective>
Build the server-side GSD command registry that reads command definitions from markdown files in a plugin directory, serves a filtered command list via REST API, and auto-updates when files change.

Purpose: This is the backend foundation for all GSD command UI (Plans 02 and 03). Without a working registry API, no client-side features can function.
Output: GSD command files, registry singleton, state filter, API route, app.ts wiring.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-gsd-command-registry/16-RESEARCH.md

# Existing code to reference:
@server/src/agent/session-manager.ts       # Session manager for hasActiveSession check
@server/src/events/reducers/project.ts     # getProjectById for project state
@server/src/events/reducers/workflow.ts    # reduceWorkflowState for step completion check
@server/src/routes/agent.ts                # Pattern for Express routes with auth
@server/src/app.ts                         # Route registration pattern
@shared/types/workflow.ts                  # WorkflowState, ProjectPhase types
@shared/types/models.ts                    # ProjectState, PROJECT_PHASES
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared GSD types, plugin command files, and registry singleton with file watcher</name>
  <files>
    shared/types/gsd.ts
    server/src/gsd/types.ts
    server/src/gsd/registry.ts
    gsd-plugin/commands/plan-phase.md
    gsd-plugin/commands/research-phase.md
    gsd-plugin/commands/analyze-code.md
    gsd-plugin/commands/review-progress.md
    gsd-plugin/commands/advance-phase.md
    gsd-plugin/commands/generate-docs.md
  </files>
  <action>
**1. Create shared GSD types** at `shared/types/gsd.ts`:

```typescript
export interface GsdCommand {
  id: string;                    // Derived from filename (e.g., "plan-phase")
  label: string;                 // Display label from frontmatter
  description: string;           // Brief description from frontmatter
  labelKey?: string;             // i18n key for label (optional)
  descriptionKey?: string;       // i18n key for description
  when: {
    phases?: string[];           // Only show in these phases (empty = all)
    notPhases?: string[];        // Hide in these phases
    requiresNoActiveSession?: boolean;  // Only if no agent session running
    requiresActiveSession?: boolean;    // Only if agent session is running
    mode?: "simple" | "expert" | "both"; // Mode restriction
  };
  promptTemplate: string;        // The prompt to send to the agent
  agentOptions?: {
    maxTurns?: number;
    maxBudgetUsd?: number;
  };
}

export interface GsdCommandRegistry {
  commands: GsdCommand[];
  loadedAt: string;              // ISO timestamp
  pluginPath: string;
}
```

**2. Create server-internal types** at `server/src/gsd/types.ts`:

```typescript
import type { ProjectPhase } from "shared/types/models.js";

export interface CommandFilterContext {
  currentPhase: ProjectPhase;
  completedStepCount: number;
  totalStepCount: number;
  hasActiveSession: boolean;
  mode: "simple" | "expert";
  archived: boolean;
}
```

**3. Create registry singleton** at `server/src/gsd/registry.ts`:

- Export `loadRegistry(pluginPath: string): Promise<GsdCommandRegistry>` that:
  - Reads all `*.md` files from `{pluginPath}/commands/`
  - Parses YAML frontmatter between `---` delimiters (use simple key: value parsing, NOT a YAML library -- frontmatter is flat key-value pairs with nested `when:` and `agentOptions:` objects)
  - Extracts the body after the second `---` as `promptTemplate`
  - Derives `id` from filename without extension (e.g., `plan-phase.md` -> `plan-phase`)
  - Stores result in module-level `registry` variable
  - Returns the registry

- Export `getRegistry(): GsdCommandRegistry | null` that returns the cached registry

- Export `watchRegistry(pluginPath: string): void` that:
  - Uses `chokidar` (import from `chokidar`) to watch `{pluginPath}/commands/` for `*.md` files
  - On add/change/unlink events, calls `loadRegistry(pluginPath)` (debounced by 500ms using a setTimeout pattern)
  - Logs `[gsd] Registry reloaded: N commands` on reload

- For frontmatter parsing, implement a simple parser (NOT a YAML library) that handles:
  - Top-level `key: value` pairs (string values)
  - Nested objects via indentation (2-space): `when:` followed by indented `phases: [...]`, `notPhases: [...]`, etc.
  - Array values in bracket notation: `[idea, feasibility]`
  - Boolean values: `true`/`false`

- Check for `GSD_PLUGIN_PATH` env var first, fallback to `path.resolve(process.cwd(), "gsd-plugin")`

**4. Create 6 GSD command markdown files** in `gsd-plugin/commands/`:

Each file has YAML frontmatter with `label`, `description`, `labelKey`, `descriptionKey`, `when` conditions, `agentOptions`, and a prompt template body.

**plan-phase.md:**
- label: "Plan Phase"
- description: "Create a detailed implementation plan for the current project phase"
- labelKey: gsd.cmd.plan_phase / descriptionKey: gsd.cmd.plan_phase_desc
- when: requiresNoActiveSession: true, mode: both
- agentOptions: maxTurns: 30, maxBudgetUsd: 3.0
- Prompt template: Analyze project "{project_name}" in phase "{current_phase}". Create a detailed implementation plan considering dependencies, effort, and risks.

**research-phase.md:**
- label: "Research Phase"
- description: "Research technologies and approaches for the current phase"
- labelKey: gsd.cmd.research_phase / descriptionKey: gsd.cmd.research_phase_desc
- when: requiresNoActiveSession: true, mode: both
- agentOptions: maxTurns: 20, maxBudgetUsd: 2.0
- Prompt: Research best approaches for project "{project_name}" in the "{current_phase}" phase.

**analyze-code.md:**
- label: "Analyze Code"
- description: "Review project code for quality, patterns, and improvement opportunities"
- labelKey: gsd.cmd.analyze_code / descriptionKey: gsd.cmd.analyze_code_desc
- when: phases: [implementation, review_extraction], requiresNoActiveSession: true, mode: both
- agentOptions: maxTurns: 25, maxBudgetUsd: 2.5
- Prompt: Analyze the codebase for project "{project_name}". Review code quality, patterns, and suggest improvements.

**review-progress.md:**
- label: "Review Progress"
- description: "Summarize project progress and identify blockers or risks"
- labelKey: gsd.cmd.review_progress / descriptionKey: gsd.cmd.review_progress_desc
- when: requiresNoActiveSession: true, mode: both
- agentOptions: maxTurns: 15, maxBudgetUsd: 1.5
- Prompt: Review the current progress of project "{project_name}" in the "{current_phase}" phase. Summarize accomplishments and identify blockers.

**advance-phase.md:**
- label: "Advance Phase"
- description: "Complete the current phase and move to the next lifecycle stage"
- labelKey: gsd.cmd.advance_phase / descriptionKey: gsd.cmd.advance_phase_desc
- when: notPhases: [review_extraction], requiresNoActiveSession: true, mode: both
- agentOptions: maxTurns: 10, maxBudgetUsd: 1.0
- Prompt: Help advance project "{project_name}" from the "{current_phase}" phase to the next phase. Verify all requirements are met.

**generate-docs.md:**
- label: "Generate Documentation"
- description: "Generate or update project documentation from current state"
- labelKey: gsd.cmd.generate_docs / descriptionKey: gsd.cmd.generate_docs_desc
- when: phases: [implementation, review_extraction], requiresNoActiveSession: true, mode: expert
- agentOptions: maxTurns: 20, maxBudgetUsd: 2.0
- Prompt: Generate comprehensive documentation for project "{project_name}". Include architecture overview, API documentation, and usage guides.
  </action>
  <verify>
- `ls gsd-plugin/commands/*.md` shows 6 command files
- `cat shared/types/gsd.ts` contains GsdCommand and GsdCommandRegistry interfaces
- `cat server/src/gsd/registry.ts` contains loadRegistry, getRegistry, watchRegistry exports
- `npx tsc --noEmit` passes with no errors in the gsd directory
  </verify>
  <done>
6 command markdown files exist in gsd-plugin/commands/ with proper frontmatter. Registry singleton can parse all 6 files and return a GsdCommandRegistry. File watcher is set up with chokidar.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state filter, API route, and wire into app.ts</name>
  <files>
    server/src/gsd/state-filter.ts
    server/src/routes/gsd.ts
    server/src/app.ts
  </files>
  <action>
**1. Create state filter** at `server/src/gsd/state-filter.ts`:

```typescript
import type { GsdCommand } from "shared/types/gsd.js";
import type { CommandFilterContext } from "./types.js";

export function filterCommands(
  commands: GsdCommand[],
  ctx: CommandFilterContext
): GsdCommand[] {
  if (ctx.archived) return []; // No commands for archived projects

  return commands.filter(cmd => {
    const w = cmd.when;

    // Phase filter
    if (w.phases?.length && !w.phases.includes(ctx.currentPhase)) return false;
    if (w.notPhases?.length && w.notPhases.includes(ctx.currentPhase)) return false;

    // Session state filter
    if (w.requiresActiveSession && !ctx.hasActiveSession) return false;
    if (w.requiresNoActiveSession && ctx.hasActiveSession) return false;

    // Mode filter
    if (w.mode && w.mode !== "both" && w.mode !== ctx.mode) return false;

    return true;
  });
}
```

**2. Create GSD route** at `server/src/routes/gsd.ts`:

- Import Router from express, getRegistry from registry, filterCommands from state-filter
- Import getProjectById from `../events/reducers/project.js`
- Import agentSessions from `../agent/session-manager.js`
- Import the workflow reducer to get step completion status
- Import loadRegistry and watchRegistry from registry

**GET /commands/:projectId** endpoint:
- Get registry via `getRegistry()`. If null, return 503 with error "Command registry not loaded"
- Get project via `getProjectById(projectId)`. If null, return 404
- Check if project has active session: iterate `agentSessions` sessions (expose a method or check directly) for running sessions on this projectId. Add a `hasActiveSessionForProject(projectId: string): boolean` public method to AgentSessionManager if not available. Actually -- add this check inline in the route: import the agentSessions singleton and check its `get` method. Since sessions are private Map, add a public method `hasRunningSession(projectId: string): boolean` to session-manager.ts that iterates sessions checking `session.projectId === projectId && session.state === "running"`.
- Read `mode` from query param: `req.query.mode === "expert" ? "expert" : "simple"`
- Build `CommandFilterContext` from project state + session check + mode
- Filter commands using `filterCommands(registry.commands, context)`
- Return `{ success: true, data: { commands: filtered, registryVersion: registry.loadedAt } }`

**Route initialization:** Export a function `initGsdRegistry(): Promise<void>` that calls `loadRegistry(pluginPath)` and `watchRegistry(pluginPath)`. This will be called from app.ts startup.

Alternatively, have the route file export the router and a separate `initGsd` function.

**3. Wire into app.ts:**
- Import gsdRouter from `./routes/gsd.js`
- Import `initGsd` from `./routes/gsd.js` (or from registry directly)
- Add `app.use("/api/gsd", requireAuth, gsdRouter);` after the agent route registration
- Call `initGsd()` during server startup (after the app is created but before listen, or inside the existing startup sequence)

**4. Add `hasRunningSession` method to session-manager.ts:**
- Add a public method: `hasRunningSession(projectId: string): boolean` that iterates `this.sessions.values()` and returns true if any session has matching projectId and state === "running"
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Server starts without errors when `npm run dev` is executed
- `curl http://localhost:3000/api/gsd/commands/{projectId}` (with auth cookie) returns JSON with commands array
- Modifying a command file in gsd-plugin/commands/ triggers a registry reload (visible in server logs: "[gsd] Registry reloaded")
  </verify>
  <done>
GET /api/gsd/commands/:projectId returns filtered commands based on project state and mode. Registry auto-reloads when command files change. Route is wired into app.ts with requireAuth middleware.
  </done>
</task>

</tasks>

<verification>
1. `ls gsd-plugin/commands/*.md | wc -l` returns 6
2. `npx tsc --noEmit` passes with zero errors
3. Server starts and GET /api/gsd/commands/:projectId returns command list
4. Editing a command file triggers automatic registry reload
5. Archived projects return empty command list
6. Phase-restricted commands (e.g., analyze-code) only appear in matching phases
</verification>

<success_criteria>
- 6 GSD command markdown files exist in gsd-plugin/commands/
- Registry singleton loads all commands at startup and watches for changes
- API endpoint returns filtered commands per project state
- Mode filter works (expert-only commands hidden in simple mode)
- No TypeScript errors across the monorepo
</success_criteria>

<output>
After completion, create `.planning/phases/16-gsd-command-registry/16-01-SUMMARY.md`
</output>
