---
phase: 16-gsd-command-registry
plan: 03
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - server/src/agent/types.ts
  - server/src/agent/session-manager.ts
  - server/src/routes/agent.ts
  - client/src/hooks/useAgentStream.ts
  - client/src/components/AgentPanel.tsx
  - client/src/i18n/locales/en.json
  - client/src/i18n/locales/de.json
autonomous: true

must_haves:
  truths:
    - "User can pause an active GSD session on a project via a Pause button"
    - "Paused session preserves the SDK session ID for later resumption"
    - "User can resume a paused session on a project via a Resume button"
    - "Pausing a session on one project does not affect sessions on other projects"
    - "Pause/resume state survives page navigation within the SPA"
  artifacts:
    - path: "server/src/agent/session-manager.ts"
      provides: "pause() and resume() methods on AgentSessionManager"
      contains: "pause("
    - path: "server/src/routes/agent.ts"
      provides: "POST /pause and POST /resume endpoints"
      contains: "router.post.*pause"
    - path: "client/src/hooks/useAgentStream.ts"
      provides: "pauseSession and resumeSession functions"
      contains: "pauseSession"
    - path: "client/src/components/AgentPanel.tsx"
      provides: "Pause and Resume buttons in agent UI"
      contains: "pause"
  key_links:
    - from: "client/src/components/AgentPanel.tsx"
      to: "client/src/hooks/useAgentStream.ts"
      via: "pauseSession/resumeSession calls"
      pattern: "pauseSession"
    - from: "client/src/hooks/useAgentStream.ts"
      to: "/api/agent/pause"
      via: "apiCall POST"
      pattern: "api/agent.*pause"
    - from: "server/src/routes/agent.ts"
      to: "server/src/agent/session-manager.ts"
      via: "agentSessions.pause() call"
      pattern: "agentSessions\\.pause"
---

<objective>
Add pause/resume capability to agent sessions so users can pause active GSD work on one project and resume it later, independently of other projects.

Purpose: GSD-05 and GSD-06 require users to manage concurrent workflows across projects. Pause/resume lets a user stop work on Project A, switch to Project B, and later return to Project A's session where they left off.
Output: Server pause/resume methods, API endpoints, client hooks and UI buttons.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-gsd-command-registry/16-RESEARCH.md
@.planning/phases/16-gsd-command-registry/16-01-SUMMARY.md
@.planning/phases/16-gsd-command-registry/16-02-SUMMARY.md

# Existing code to modify:
@server/src/agent/types.ts             # AgentSessionState, AgentSession types
@server/src/agent/session-manager.ts   # AgentSessionManager singleton
@server/src/routes/agent.ts            # Agent REST endpoints
@client/src/hooks/useAgentStream.ts    # useAgentStream hook
@client/src/components/AgentPanel.tsx   # AgentPanel UI component
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pause/resume to AgentSessionManager, types, and API routes</name>
  <files>
    server/src/agent/types.ts
    server/src/agent/session-manager.ts
    server/src/routes/agent.ts
  </files>
  <action>
**1. Update AgentSessionState** in `server/src/agent/types.ts`:

Add `"paused"` to the AgentSessionState union:
```typescript
export type AgentSessionState =
  | "starting"
  | "running"
  | "completed"
  | "errored"
  | "aborted"
  | "paused";
```

Add `sdkSessionId` field to `AgentSession`:
```typescript
export interface AgentSession {
  // ... existing fields ...
  sdkSessionId: string | null;  // Captured from SDK init message for resume
}
```

Add `sdkSessionId` to `AgentSessionInfo`:
```typescript
export interface AgentSessionInfo {
  // ... existing fields ...
  sdkSessionId: string | null;
}
```

Add `PausedSessionInfo` type for storing paused session metadata:
```typescript
export interface PausedSessionInfo {
  projectId: string;
  sdkSessionId: string;
  userId: string;
  pausedAt: string;
  bufferSnapshot: SSEEvent[];  // Last N events for context display on resume
}
```

**2. Modify AgentSessionManager** in `server/src/agent/session-manager.ts`:

Add a `pausedSessions` Map alongside the existing `sessions` Map:
```typescript
private pausedSessions = new Map<string, PausedSessionInfo>();
```

Update `consumeStream` to capture the SDK session ID from the init message:
```typescript
// Inside the for-await loop, before adaptMessage:
// Check for init message that contains session_id
if (message.type === "system" && (message as Record<string, unknown>).subtype === "init") {
  session.sdkSessionId = (message as Record<string, unknown>).session_id as string;
}
```

Note: The SDK message types may not expose `session_id` directly. Check the actual SDK message shape. If the init message has a `session_id` field, capture it. If not available, the `query` object itself may expose a session ID. Check `session.query` for a `.sessionId` property. As a fallback, generate a UUID and pass it as the `sessionId` option when calling `query()`.

Actually, per the research (Pattern 6), the Agent SDK `query()` returns messages where the init message has a `session_id`. The SDK's `query()` options accept a `sessionId` to set explicitly. For resume to work:
- When starting a session, let the SDK auto-generate a session ID
- Capture it from the init message stream
- When resuming, pass `resume: capturedSessionId` to a new `query()` call

For the `start` method: initialize `sdkSessionId` as null. It gets set during stream consumption.

Add `pause(sessionId: string)` method:
```typescript
pause(sessionId: string): PausedSessionInfo | null {
  const session = this.sessions.get(sessionId);
  if (!session || session.state !== "running") return null;
  if (!session.sdkSessionId) return null; // Can't resume without SDK session ID

  // Mark as paused
  session.state = "paused";
  session.abortController.abort();
  session.query.close();
  this.clearTimeout(session);

  // Emit pause event
  const event: SSEEvent = {
    type: "status",
    data: { message: "Session paused" },
    timestamp: new Date().toISOString(),
  };
  this.pushEvent(session, event);
  session.emitter.emit("end");

  // Store paused session info
  const pausedInfo: PausedSessionInfo = {
    projectId: session.projectId!,
    sdkSessionId: session.sdkSessionId,
    userId: session.userId,
    pausedAt: new Date().toISOString(),
    bufferSnapshot: session.buffer.slice(-50), // Last 50 events for context
  };
  this.pausedSessions.set(session.projectId!, pausedInfo);

  // Remove from active sessions
  this.sessions.delete(sessionId);

  console.log(`[agent] Session ${sessionId} paused (SDK: ${session.sdkSessionId})`);
  return pausedInfo;
}
```

Add `resume(projectId: string, userId: string)` method:
```typescript
resume(projectId: string, userId: string): { sessionId: string; replayEvents: SSEEvent[] } | null {
  const paused = this.pausedSessions.get(projectId);
  if (!paused) return null;
  if (paused.userId !== userId) return null;

  // Remove from paused
  this.pausedSessions.delete(projectId);

  // Start a new session with resume
  const id = randomUUID();
  const abortController = new AbortController();

  const agentQuery = query({
    prompt: "Continue where you left off",
    options: {
      cwd: process.cwd(),
      abortController,
      canUseTool,
      permissionMode: "default",
      includePartialMessages: true,
      maxTurns: 25,
      maxBudgetUsd: 2.0,
      persistSession: true,   // Enable persistence for future pauses
      resume: paused.sdkSessionId,  // Resume the SDK session
      settingSources: [],
    },
  });

  const emitter = new EventEmitter();
  emitter.setMaxListeners(20);

  const session: AgentSession = {
    id,
    userId,
    projectId,
    state: "running",
    query: agentQuery,
    abortController,
    createdAt: new Date(),
    buffer: [],
    emitter,
    timeoutHandle: null,
    sdkSessionId: paused.sdkSessionId,
  };

  session.timeoutHandle = setTimeout(() => {
    this.abort(id);
  }, SESSION_TIMEOUT_MS);

  this.sessions.set(id, session);
  this.consumeStream(session);

  console.log(`[agent] Session resumed for project ${projectId} (SDK: ${paused.sdkSessionId})`);
  return { sessionId: id, replayEvents: paused.bufferSnapshot };
}
```

Add `getPausedSession(projectId: string)` method:
```typescript
getPausedSession(projectId: string): PausedSessionInfo | null {
  return this.pausedSessions.get(projectId) ?? null;
}
```

Update the `start` method to initialize `sdkSessionId: null` in the session object.

Update `getInfo` to include `sdkSessionId`.

Update `cleanup` to also clear pausedSessions.

**3. Add pause/resume API routes** in `server/src/routes/agent.ts`:

**POST /pause/:sessionId** endpoint:
- Auth check (same as other endpoints)
- Get session, verify userId ownership
- Call `agentSessions.pause(sessionId)`
- Return `{ success: true, data: { paused: true, projectId, sdkSessionId } }`
- On failure: 400 if session not running, 404 if not found

**POST /resume/:projectId** endpoint:
- Auth check
- Call `agentSessions.resume(projectId, userId)`
- Return `{ success: true, data: { sessionId, replayEvents } }`
- On failure: 404 if no paused session, 403 if different user

**GET /paused/:projectId** endpoint:
- Auth check
- Call `agentSessions.getPausedSession(projectId)`
- Return `{ success: true, data: pausedInfo }` or 404

Update the per-project enforcement in `start` to also check for paused sessions -- if a project has a paused session, the user should resume instead of starting new. Return 409 with error "Paused session exists for this project. Resume it or discard it first."
  </action>
  <verify>
- `npx tsc --noEmit` passes
- POST /api/agent/pause/:sessionId returns 200 with paused info when session is running
- POST /api/agent/resume/:projectId returns 201 with new sessionId when a paused session exists
- GET /api/agent/paused/:projectId returns paused session info
- Starting a new session on a project with a paused session returns 409
  </verify>
  <done>
AgentSessionManager has pause(), resume(), and getPausedSession() methods. API routes expose POST /pause, POST /resume, and GET /paused. Pausing stores SDK session ID for resumption. Per-project enforcement prevents starting new sessions when paused session exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pause/resume to client hooks and AgentPanel UI</name>
  <files>
    client/src/hooks/useAgentStream.ts
    client/src/components/AgentPanel.tsx
    client/src/i18n/locales/en.json
    client/src/i18n/locales/de.json
  </files>
  <action>
**1. Update `useAgentStream`** hook at `client/src/hooks/useAgentStream.ts`:

Add `"paused"` to `StreamStatus`:
```typescript
export type StreamStatus = "idle" | "starting" | "streaming" | "reconnecting" | "paused" | "done" | "error";
```

Add `pauseSession` and `resumeSession` functions:

```typescript
// Add to UseAgentStreamReturn interface:
pauseSession: () => Promise<void>;
resumeSession: (projectId: string) => Promise<void>;
hasPausedSession: boolean;
```

Add state:
```typescript
const [hasPausedSession, setHasPausedSession] = useState(false);
```

Implement `pauseSession`:
```typescript
const pauseSession = useCallback(async (): Promise<void> => {
  if (!sessionIdRef.current) return;

  // Close SSE connection
  if (eventSourceRef.current) {
    eventSourceRef.current.close();
    eventSourceRef.current = null;
  }

  const response = await apiCall<{ paused: boolean; projectId: string }>(
    "POST",
    `/api/agent/pause/${sessionIdRef.current}`
  );

  if (response.success) {
    setStatus("paused");
    setCurrentTool(null);
    setHasPausedSession(true);
    sessionIdRef.current = null;
  }
}, []);
```

Implement `resumeSession`:
```typescript
const resumeSession = useCallback(async (projectId: string): Promise<void> => {
  // Reset display state
  setChunks([]);
  setResult(null);
  setError(null);
  setCurrentTool(null);
  setStatusMessage(null);
  setStatus("starting");

  const response = await apiCall<{ sessionId: string; replayEvents: SSEEvent[] }>(
    "POST",
    `/api/agent/resume/${projectId}`
  );

  if (!response.success) {
    setError(response.error);
    setStatus("error");
    setHasPausedSession(false);
    return;
  }

  // Replay buffer snapshot as initial chunks
  for (const event of response.data.replayEvents) {
    if (event.type === "text") {
      setChunks(prev => [...prev, (event.data as { text: string }).text]);
    }
  }

  setHasPausedSession(false);
  sessionIdRef.current = response.data.sessionId;
  connectStream(response.data.sessionId);
}, [connectStream]);
```

Add a `checkPausedSession` function that the component can call on mount:
```typescript
const checkPausedSession = useCallback(async (projectId: string): Promise<boolean> => {
  const response = await apiCall<PausedSessionInfo | null>("GET", `/api/agent/paused/${projectId}`);
  const hasPaused = response.success && response.data !== null;
  setHasPausedSession(hasPaused);
  return hasPaused;
}, []);
```

Return all new functions and state from the hook.

**2. Update AgentPanel** at `client/src/components/AgentPanel.tsx`:

Add Pause button next to Cancel during active session:
- Show "Pause" button when `status === "streaming"` (not during "starting" since SDK session ID may not be captured yet)
- Pause button: style similar to cancel but with amber color (#d97706 background) to differentiate from abort
- On click: call `pauseSession()`

Add Resume button when paused session exists:
- On component mount (useEffect), check for paused session: `checkPausedSession(projectId)`
- If `hasPausedSession` is true, show a banner with "Paused session available" message and a "Resume" button
- Resume button: style with green (#059669 background) to indicate continuation
- On click: call `resumeSession(projectId)`
- While resuming, show the same loading state as session start

Update the `isActive` check to include paused state:
```typescript
const isActive = status === "starting" || status === "streaming" || status === "reconnecting";
const isPaused = status === "paused" || hasPausedSession;
```

When paused, show the GsdButtonBar (command buttons) alongside the resume banner, so the user can choose to resume or start a different command.

Layout when paused session exists:
```
[Resume banner: "You have a paused session on this project." [Resume] [Discard]]
[GSD command buttons below]
```

Add a "Discard" button on the resume banner that discards the paused session. Call a new `discardPausedSession` endpoint (add to routes: DELETE /paused/:projectId) or simply start a new session which should override.

Actually, to keep it simple: the resume banner has "Resume" and "Start New" buttons. "Start New" discards the paused state and shows the normal command buttons. This avoids needing a separate discard endpoint -- just clear the local `hasPausedSession` state and let the server handle it when a new session starts. Update the server-side `start` method to auto-discard any paused session for the project when a new session is explicitly started (remove the 409 check for paused sessions, or add a `force` option).

Revised server behavior: When `POST /start` is called and a paused session exists for the project, automatically discard the paused session and start fresh. This is simpler than requiring the client to explicitly discard first.

**3. Add i18n keys** to both locale files:

English (add under `agent` section):
```json
"agent": {
  // ... existing keys ...
  "pause": "Pause",
  "resume": "Resume",
  "paused_banner": "You have a paused GSD session on this project.",
  "start_new": "Start New",
  "resuming": "Resuming session..."
}
```

German:
```json
"agent": {
  // ... existing keys ...
  "pause": "Pausieren",
  "resume": "Fortsetzen",
  "paused_banner": "Sie haben eine pausierte GSD-Sitzung f√ºr dieses Projekt.",
  "start_new": "Neu starten",
  "resuming": "Sitzung wird fortgesetzt..."
}
```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- During active streaming, a "Pause" button appears next to Cancel/Abort
- Clicking Pause stops the stream and shows the paused banner on next visit
- Paused banner shows "Resume" and "Start New" options
- Clicking Resume reconnects to the paused session and shows streaming output
- Pausing project A and navigating to project B: project B has no paused state
- i18n keys exist in both en.json and de.json
  </verify>
  <done>
Pause button appears during active streaming. Clicking pause stops the session and stores the SDK session ID. Resume banner appears when visiting a project with a paused session. Resume reconnects to the SDK session. Multiple projects have independent pause states.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across entire monorepo
2. During active streaming, Pause button is visible and functional
3. After pausing, navigating away and back shows resume banner -- GSD-05
4. Resume reconnects to the SDK session and shows continued output
5. Two different projects can have independent paused sessions -- GSD-06
6. "Start New" on resume banner discards paused session and shows command buttons
7. All new strings in both en.json and de.json
</verification>

<success_criteria>
- Pause button stops active session and stores SDK session ID
- Resume banner appears for projects with paused sessions
- Resume reconnects to SDK session via the `resume` option
- Per-project independence: pause/resume on one project doesn't affect others
- All UI text internationalized in EN and DE
</success_criteria>

<output>
After completion, create `.planning/phases/16-gsd-command-registry/16-03-SUMMARY.md`
</output>
