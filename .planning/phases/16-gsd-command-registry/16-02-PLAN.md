---
phase: 16-gsd-command-registry
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - client/package.json
  - client/src/hooks/useGsdCommands.ts
  - client/src/components/GsdButtonBar.tsx
  - client/src/components/GsdCommandPalette.tsx
  - client/src/pages/ProjectDetail.tsx
  - client/src/App.tsx
  - client/src/i18n/locales/en.json
  - client/src/i18n/locales/de.json
autonomous: true

must_haves:
  truths:
    - "Project detail page shows GSD action buttons relevant to the current project state"
    - "Each GSD button displays a label and a brief description underneath"
    - "Clicking a GSD button starts an agent session with that command's prompt"
    - "In Expert mode, Cmd+K opens a command palette with fuzzy search of all GSD commands"
    - "In Simple mode, Cmd+K does nothing and command palette is not rendered"
  artifacts:
    - path: "client/src/hooks/useGsdCommands.ts"
      provides: "Hook to fetch and cache GSD commands for a project"
      exports: ["useGsdCommands"]
    - path: "client/src/components/GsdButtonBar.tsx"
      provides: "Context-dependent GSD action buttons with label and description"
      exports: ["GsdButtonBar"]
    - path: "client/src/components/GsdCommandPalette.tsx"
      provides: "Cmd+K command palette for Expert mode"
      exports: ["GsdCommandPalette"]
  key_links:
    - from: "client/src/hooks/useGsdCommands.ts"
      to: "/api/gsd/commands/:projectId"
      via: "apiCall GET"
      pattern: "api/gsd/commands"
    - from: "client/src/components/GsdButtonBar.tsx"
      to: "client/src/hooks/useAgentStream.ts"
      via: "startSession() call"
      pattern: "startSession"
    - from: "client/src/components/GsdCommandPalette.tsx"
      to: "cmdk"
      via: "Command.Dialog import"
      pattern: "from.*cmdk"
    - from: "client/src/pages/ProjectDetail.tsx"
      to: "client/src/components/GsdButtonBar.tsx"
      via: "component import"
      pattern: "GsdButtonBar"
---

<objective>
Build the client-side GSD command UI: a button bar showing context-dependent commands with labels and descriptions, and a Cmd+K command palette for Expert mode with fuzzy search.

Purpose: This plan delivers the user-facing GSD experience. Users see relevant action buttons on their project and can execute commands. Expert users get keyboard-driven access via Cmd+K.
Output: useGsdCommands hook, GsdButtonBar component, GsdCommandPalette component, ProjectDetail integration, i18n keys.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-gsd-command-registry/16-RESEARCH.md
@.planning/phases/16-gsd-command-registry/16-01-SUMMARY.md

# Existing code to reference:
@client/src/hooks/useAgentStream.ts    # startSession function to trigger agent
@client/src/hooks/useMode.ts           # useMode hook for isExpert check
@client/src/components/AgentPanel.tsx   # Current agent UI to integrate alongside
@client/src/pages/ProjectDetail.tsx    # Target page for GsdButtonBar integration
@client/src/api/client.ts             # apiCall for API requests
@shared/types/gsd.ts                  # GsdCommand type from Plan 01
@client/src/i18n/locales/en.json      # Existing i18n structure
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install cmdk, create useGsdCommands hook and GsdButtonBar, integrate into ProjectDetail</name>
  <files>
    client/package.json
    client/src/hooks/useGsdCommands.ts
    client/src/components/GsdButtonBar.tsx
    client/src/pages/ProjectDetail.tsx
    client/src/i18n/locales/en.json
    client/src/i18n/locales/de.json
  </files>
  <action>
**1. Install cmdk:**
```bash
npm install cmdk -w client
```

**2. Create `useGsdCommands` hook** at `client/src/hooks/useGsdCommands.ts`:

```typescript
import { useState, useEffect, useCallback } from "react";
import { apiCall } from "../api/client.js";
import type { GsdCommand } from "shared/types/gsd.js";
import { useMode } from "./useMode.js";

interface UseGsdCommandsReturn {
  commands: GsdCommand[];
  loading: boolean;
  error: string | null;
  refresh: () => void;
}

export function useGsdCommands(projectId: string): UseGsdCommandsReturn {
  const [commands, setCommands] = useState<GsdCommand[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { mode } = useMode();

  const fetchCommands = useCallback(async () => {
    setLoading(true);
    setError(null);
    const res = await apiCall<{ commands: GsdCommand[]; registryVersion: string }>(
      "GET",
      `/api/gsd/commands/${projectId}?mode=${mode}`
    );
    if (res.success) {
      setCommands(res.data.commands);
    } else {
      setError(res.error);
    }
    setLoading(false);
  }, [projectId, mode]);

  useEffect(() => {
    fetchCommands();
  }, [fetchCommands]);

  return { commands, loading, error, refresh: fetchCommands };
}
```

**3. Create `GsdButtonBar` component** at `client/src/components/GsdButtonBar.tsx`:

- Props: `{ projectId: string }` (no need to pass startSession -- it uses its own useAgentStream instance or calls through the existing AgentPanel)
- Actually, re-think: The GsdButtonBar needs to trigger a session that the AgentPanel displays. Both need to share the same useAgentStream state. Two approaches:
  - (A) Lift useAgentStream to the parent (ProjectDetail) and pass handlers down to both GsdButtonBar and AgentPanel
  - (B) GsdButtonBar calls the `/api/agent/start` endpoint directly and the AgentPanel's stream picks it up

Best approach: **(A) Lift state**. Modify the integration so ProjectDetail owns useAgentStream, and passes `startSession` down to GsdButtonBar and the stream state down to AgentPanel. This requires refactoring AgentPanel to accept stream state as props instead of using its own hook instance.

However, to minimize changes to AgentPanel (which works well), use approach **(B)**: GsdButtonBar starts the session via a shared callback from the parent, and AgentPanel observes the session via its existing hook. The problem is that useAgentStream in AgentPanel would not know about a session started externally.

Simplest correct approach: **Replace the AgentPanel prompt input with GsdButtonBar when commands are available.** The GsdButtonBar buttons call the same `startSession` that AgentPanel uses internally. To make this work:

- Refactor: Extract `useAgentStream` state to be owned by ProjectDetail (lift up)
- Pass `startSession` to GsdButtonBar, pass stream state to AgentPanel
- AgentPanel becomes a "display" component (accepts stream state as props)
- GsdButtonBar buttons call `startSession({ prompt: cmd.promptTemplate, projectId, commandId: cmd.id })`

Implementation:
- **GsdButtonBar** receives: `commands: GsdCommand[]`, `onExecute: (cmd: GsdCommand) => void`, `loading: boolean`
- Renders a grid of buttons. Each button shows:
  - `cmd.labelKey ? t(cmd.labelKey) : cmd.label` as the button label (bold, 14px)
  - `cmd.descriptionKey ? t(cmd.descriptionKey) : cmd.description` as subtitle (12px, gray)
- On click: `onExecute(cmd)`
- If `loading` is true, show a subtle loading skeleton (or nothing)
- If commands is empty and not loading, show nothing (don't show empty state for archived projects etc.)
- Use inline styles following project convention:
  - Container: flex wrap, gap 8px
  - Each button: white card with 1px border #d1d5db, border-radius 8px, padding 12px 16px, text-align left, hover: border-color #2563eb, transition 0.15s
  - Label: display block, font-weight 600, font-size 14px, color #1f2937
  - Description: display block, font-size 12px, color #6b7280, margin-top 2px

**4. Integrate into ProjectDetail:**

In `ProjectDetail.tsx`:
- Import `useGsdCommands` and `GsdButtonBar`
- Call `useGsdCommands(project.id)` where project is available
- Render `<GsdButtonBar>` above the existing AgentPanel section (but below the phase timeline)
- When a GSD button is clicked: call a function that sets a prompt state, which the AgentPanel uses. Simplest approach: add a `defaultPrompt` state in ProjectDetail. When a GSD button is clicked, set `defaultPrompt` to the command's promptTemplate. AgentPanel receives `defaultPrompt` prop and auto-starts the session.

Actually the cleanest approach for minimal disruption:
- In ProjectDetail, when user clicks a GSD command button, directly call useAgentStream's startSession from a lifted hook. But this requires lifting useAgentStream out of AgentPanel.
- Alternative: Add an `onCommandExecute` handler in ProjectDetail that uses a ref to trigger AgentPanel.

Simplest working approach: **Add `initialPrompt` prop to AgentPanel.** When GsdButtonBar button is clicked:
1. Set state `activeCommand` in ProjectDetail to the command
2. Pass `activeCommand.promptTemplate` as `initialPrompt` to AgentPanel
3. AgentPanel, when it receives a non-empty `initialPrompt` that differs from previous, auto-calls `startSession({ prompt: initialPrompt, projectId })`
4. After session starts, GsdButtonBar hides (since session is active) and AgentPanel shows streaming output

Implement this as follows in ProjectDetail:
```tsx
const [activeCommand, setActiveCommand] = useState<GsdCommand | null>(null);

function handleCommandExecute(cmd: GsdCommand) {
  setActiveCommand(cmd);
}

// In JSX, inside non-archived section:
{!project.archived && (
  <>
    <GsdButtonBar
      commands={gsdCommands}
      loading={gsdLoading}
      onExecute={handleCommandExecute}
    />
    <AgentPanel
      projectId={project.id}
      initialPrompt={activeCommand?.promptTemplate ?? undefined}
      onSessionEnd={() => { setActiveCommand(null); gsdRefresh(); }}
    />
  </>
)}
```

Update AgentPanel to accept `initialPrompt?: string` and `onSessionEnd?: () => void`:
- When `initialPrompt` changes from undefined to a string, auto-call `startSession({ prompt: initialPrompt, projectId })`
- Use a `useEffect` watching `initialPrompt` to trigger auto-start
- When session ends (status becomes "done" or "error"), call `onSessionEnd` if provided
- GsdButtonBar remains hidden during active sessions since the AgentPanel takes over the visual space
- After session ends and user clicks "New Session", `onSessionEnd` fires, which resets `activeCommand` and refreshes the command list

**5. Add i18n keys** to both `en.json` and `de.json`:

English keys (add under new `gsd` section):
```json
"gsd": {
  "cmd": {
    "plan_phase": "Plan Phase",
    "plan_phase_desc": "Create a detailed implementation plan for the current project phase",
    "research_phase": "Research Phase",
    "research_phase_desc": "Research technologies and approaches for the current phase",
    "analyze_code": "Analyze Code",
    "analyze_code_desc": "Review project code for quality, patterns, and improvement opportunities",
    "review_progress": "Review Progress",
    "review_progress_desc": "Summarize project progress and identify blockers or risks",
    "advance_phase": "Advance Phase",
    "advance_phase_desc": "Complete the current phase and move to the next lifecycle stage",
    "generate_docs": "Generate Documentation",
    "generate_docs_desc": "Generate or update project documentation from current state"
  },
  "actions_title": "GSD Actions",
  "no_commands": "No actions available",
  "command_palette": "Command Palette",
  "search_commands": "Search commands..."
}
```

German keys (matching):
```json
"gsd": {
  "cmd": {
    "plan_phase": "Phase planen",
    "plan_phase_desc": "Einen detaillierten Umsetzungsplan für die aktuelle Projektphase erstellen",
    "research_phase": "Phase recherchieren",
    "research_phase_desc": "Technologien und Ansätze für die aktuelle Phase erforschen",
    "analyze_code": "Code analysieren",
    "analyze_code_desc": "Projektcode auf Qualität, Muster und Verbesserungsmöglichkeiten prüfen",
    "review_progress": "Fortschritt prüfen",
    "review_progress_desc": "Projektfortschritt zusammenfassen und Blocker oder Risiken identifizieren",
    "advance_phase": "Phase vorantreiben",
    "advance_phase_desc": "Die aktuelle Phase abschließen und zur nächsten Lebenszyklusphase übergehen",
    "generate_docs": "Dokumentation generieren",
    "generate_docs_desc": "Projektdokumentation aus dem aktuellen Stand generieren oder aktualisieren"
  },
  "actions_title": "GSD-Aktionen",
  "no_commands": "Keine Aktionen verfügbar",
  "command_palette": "Befehlspalette",
  "search_commands": "Befehle suchen..."
}
```
  </action>
  <verify>
- `npm install` completes without errors (cmdk installed)
- `npx tsc --noEmit` passes
- ProjectDetail page shows GSD action buttons for non-archived projects
- Clicking a GSD button starts an agent session and shows streaming output in AgentPanel
- Each button displays a label (bold) and description (gray subtitle)
- i18n keys exist in both en.json and de.json under `gsd.*`
  </verify>
  <done>
GsdButtonBar renders context-dependent command buttons on ProjectDetail. Clicking a button triggers an agent session with the command's prompt. Each button shows label and description. i18n keys added for all 6 commands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GsdCommandPalette (Expert mode Cmd+K) and wire into App.tsx</name>
  <files>
    client/src/components/GsdCommandPalette.tsx
    client/src/App.tsx
  </files>
  <action>
**1. Create `GsdCommandPalette`** at `client/src/components/GsdCommandPalette.tsx`:

This is the Expert-mode-only Cmd+K command palette using cmdk.

```tsx
import { Command } from "cmdk";
import { useState, useEffect } from "react";
import { useTranslation } from "react-i18next";
import { useMode } from "../hooks/useMode.js";
```

Props: `{ projectId: string | null }` -- null when no project is selected (palette disabled).

Behavior:
- Only renders when `isExpert` is true
- Registers Cmd+K (metaKey on Mac, ctrlKey on Win) keydown listener via useEffect, only when isExpert
- On Cmd+K, toggles `open` state
- When `open` and `projectId` is available, fetches commands via `useGsdCommands(projectId)` (or receives them via prop -- for simplicity, the palette fetches its own commands since it's a global component)
- Actually, since the palette needs a projectId and it's rendered globally in App.tsx, it needs to know the current project. Two options:
  - (A) Read projectId from URL via useParams (but it's outside Routes)
  - (B) Use a context or global state for current project ID

Simplest approach: **Render GsdCommandPalette inside ProjectDetail** (not App.tsx), so it naturally has projectId. Expert mode users viewing a project can Cmd+K. When not on a project page, Cmd+K does nothing.

Revised plan:
- Render `<GsdCommandPalette projectId={project.id} commands={gsdCommands} />` inside ProjectDetail, next to GsdButtonBar
- The palette component just manages the dialog open/close and Cmd+K listener
- It receives `commands` as a prop (already fetched by useGsdCommands in ProjectDetail)
- When user selects a command from the palette, call the same `onExecute` handler

Implementation:
- Uses `Command.Dialog` from cmdk with `open` and `onOpenChange` props
- `Command.Input` with placeholder `t("gsd.search_commands")`
- `Command.List` mapping over commands
- `Command.Item` for each command, `value` is `${cmd.label} ${cmd.description}` for fuzzy matching
- `Command.Empty` with `t("gsd.no_commands")`
- On select: close dialog, call `onExecute(cmd)`

Inline styles for the palette (following Eluma convention -- NO external CSS):
- Dialog overlay: fixed inset-0, background rgba(0,0,0,0.4), z-index 9999, display flex, justify center, align start, padding-top 20vh
- Dialog content: background white, border-radius 12px, box-shadow 0 25px 50px rgba(0,0,0,0.25), width 500px, max-height 400px, overflow hidden
- Input: width 100%, padding 16px, font-size 16px, border none, border-bottom 1px solid #e5e7eb, outline none
- List: max-height 300px, overflow-y auto, padding 8px
- Item: padding 10px 16px, border-radius 6px, cursor pointer, display flex, flex-direction column, gap 2px. Selected state handled by cmdk data attributes: `[data-selected="true"]` -> background #f3f4f6
- Item label: font-size 14px, font-weight 500, color #1f2937
- Item description: font-size 12px, color #6b7280
- Empty: padding 20px, text-align center, color #9ca3af, font-size 14px

**IMPORTANT cmdk styling note:** cmdk v1 applies `data-selected` attribute to items. Since Eluma uses inline styles (not CSS), we cannot use attribute selectors directly. Two approaches:
- (A) Use a tiny `<style>` tag injected via the component for the `[cmdk-item][data-selected="true"]` selector
- (B) Use cmdk's `onSelect` and track selected state manually

Use approach **(A)**: Add a `<style>` tag inside the component:
```tsx
<style>{`
  [cmdk-item][data-selected="true"] {
    background-color: #f3f4f6;
  }
  [cmdk-item]:hover {
    background-color: #f9fafb;
  }
`}</style>
```

This is a minimal exception to the inline-only convention, justified by cmdk's attribute-based selection system.

**2. Wire into ProjectDetail:**

In ProjectDetail, alongside the GsdButtonBar rendering:
```tsx
{isExpert && (
  <GsdCommandPalette
    projectId={project.id}
    commands={gsdCommands}
    onExecute={handleCommandExecute}
  />
)}
```

Import `useMode` in ProjectDetail to get `isExpert`.

**3. No changes needed to App.tsx** -- the palette is rendered per-project inside ProjectDetail, not globally. This is cleaner since the palette needs project context.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- In Expert mode on a ProjectDetail page, pressing Cmd+K opens the command palette
- Typing in the palette filters commands by fuzzy matching
- Selecting a command from the palette triggers the agent session
- In Simple mode, Cmd+K does nothing
- Pressing Escape closes the palette
  </verify>
  <done>
GsdCommandPalette renders in Expert mode on ProjectDetail pages. Cmd+K opens it, fuzzy search filters commands, selecting a command executes it. Simple mode has no palette.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across entire monorepo
2. ProjectDetail shows GSD action buttons for non-archived projects
3. Each button has label (bold) and description (gray) -- GSD-03
4. Only phase-relevant commands appear (e.g., "Analyze Code" only in implementation/review phases) -- GSD-02
5. Clicking button triggers agent session with streaming output in AgentPanel
6. Expert mode Cmd+K opens command palette with fuzzy search -- GSD-04
7. Simple mode Cmd+K is inert
8. All strings in both en.json and de.json
</verification>

<success_criteria>
- GsdButtonBar shows context-filtered commands with labels and descriptions
- Clicking a GSD button starts an agent session with the command prompt
- Expert mode Cmd+K opens cmdk command palette with fuzzy search
- All UI text uses i18n in both EN and DE
- cmdk package installed in client workspace
</success_criteria>

<output>
After completion, create `.planning/phases/16-gsd-command-registry/16-02-SUMMARY.md`
</output>
