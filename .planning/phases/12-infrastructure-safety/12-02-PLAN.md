---
phase: 12-infrastructure-safety
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - server/src/agent/sse-writer.ts
  - server/src/agent/session-manager.ts
  - server/src/routes/agent.ts
  - server/src/app.ts
autonomous: true

must_haves:
  truths:
    - "SSE responses stream to the browser incrementally without compression middleware buffering"
    - "Server can instantiate an Agent SDK session that calls query()"
    - "Stopping the server with SIGTERM cleans up any active agent sessions before exit"
    - "A final SSE event notifies clients their session was interrupted before server closes connection"
  artifacts:
    - path: "server/src/agent/sse-writer.ts"
      provides: "SSE response writer with res.flush(), sequential event IDs, heartbeat, structured JSON"
      exports: ["createSSEWriter", "SSEWriter"]
    - path: "server/src/agent/session-manager.ts"
      provides: "Agent session lifecycle management: create, track, abort, cleanup, shutdown"
      exports: ["agentSessionManager", "AgentSessionManager"]
    - path: "server/src/routes/agent.ts"
      provides: "Test endpoint to verify Agent SDK query() and SSE streaming work end-to-end"
      exports: ["default"]
    - path: "server/src/app.ts"
      provides: "Updated graceful shutdown with agent session cleanup, agent route registered"
      contains: "agentSessionManager"
  key_links:
    - from: "server/src/agent/session-manager.ts"
      to: "server/src/agent/tool-permissions.ts"
      via: "canUseTool import for query() options"
      pattern: "import.*canUseTool.*tool-permissions"
    - from: "server/src/agent/session-manager.ts"
      to: "server/src/agent/sse-writer.ts"
      via: "createSSEWriter for streaming output"
      pattern: "import.*createSSEWriter.*sse-writer"
    - from: "server/src/agent/session-manager.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "query() async generator"
      pattern: "import.*query.*claude-agent-sdk"
    - from: "server/src/app.ts"
      to: "server/src/agent/session-manager.ts"
      via: "gracefulShutdown calls agentSessionManager.shutdownAll()"
      pattern: "agentSessionManager\\.shutdownAll"
    - from: "server/src/routes/agent.ts"
      to: "server/src/agent/session-manager.ts"
      via: "test endpoint creates session"
      pattern: "agentSessionManager"
---

<objective>
Create the SSE streaming writer, agent session manager, and wire everything into the Express app with graceful shutdown. Includes a test endpoint to prove the full stack works end-to-end.

Purpose: Completes the infrastructure layer. The SSE writer ensures real-time streaming without compression buffering. The session manager provides the lifecycle API that Phase 13+ builds on. The graceful shutdown ensures no orphaned agent processes on server stop. The test endpoint proves all 5 INFRA requirements are satisfied.
Output: SSE writer utility, session manager with full lifecycle, graceful shutdown integration, test endpoint at POST /api/agent/test and GET /api/agent/test/stream/:sessionId.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-infrastructure-safety/12-RESEARCH.md
@.planning/phases/12-infrastructure-safety/12-CONTEXT.md
@.planning/phases/12-infrastructure-safety/12-01-SUMMARY.md
@server/src/app.ts
@server/src/index.ts
@server/src/agent/types.ts
@server/src/agent/tool-permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE writer utility with flush, event IDs, and heartbeat</name>
  <files>
    server/src/agent/sse-writer.ts
  </files>
  <action>
    Create `server/src/agent/sse-writer.ts` -- a utility for writing SSE events to Express responses with compression-safe flushing.

    1. Define `SSEWriter` interface with methods:
       - `send(type: string, data: unknown): void` -- writes a formatted SSE event
       - `close(): void` -- stops heartbeat and marks as closed

    2. Export `createSSEWriter(res: express.Response): SSEWriter` factory function:
       a. Initialize `eventId` counter starting at 0.
       b. Set SSE response headers on `res`:
          - `Content-Type: text/event-stream`
          - `Cache-Control: no-cache`
          - `Connection: keep-alive`
          - `X-Accel-Buffering: no` (disables nginx buffering if present)
       c. Call `res.flushHeaders()` to send headers immediately.
       d. Start heartbeat interval at 15 seconds (per research recommendation). Heartbeat writes SSE comment format: `": heartbeat\n\n"` followed by `(res as any).flush?.()`. SSE comments do not fire EventSource event handlers on the client.
       e. `send(type, data)` method:
          - Increment `eventId`
          - Write formatted SSE: `id: ${eventId}\nevent: ${type}\ndata: ${JSON.stringify(data)}\n\n`
          - Call `(res as any).flush?.()` after EVERY write (CRITICAL: this is what fixes compression middleware buffering, per expressjs/compression#17)
          - If `closed` flag is true, return early without writing
       f. `close()` method:
          - Set `closed = true`
          - Clear heartbeat interval

    Per user decisions:
    - Event IDs are sequential integers per stream (prepares for Phase 13 reconnection)
    - Structured JSON payloads for all events (client parses and renders)
    - Heartbeat at 15 seconds (within Cloudflare Tunnel 60-120s idle timeout)

    Import express types but do NOT import the express module itself (this is a utility, not a route).
  </action>
  <verify>
    1. `cd /Users/developer/eluma && npx tsc --noEmit` -- no type errors
    2. Verify exports: `cd /Users/developer/eluma && node --import tsx/esm -e "import { createSSEWriter } from './server/src/agent/sse-writer.ts'; console.log('SSE writer OK, type:', typeof createSSEWriter)"`
  </verify>
  <done>
    - server/src/agent/sse-writer.ts exports createSSEWriter and SSEWriter type
    - SSE writer sets correct headers (text/event-stream, no-cache, keep-alive, X-Accel-Buffering: no)
    - Every write calls res.flush() for compression bypass
    - Event IDs are sequential integers starting from 1
    - Heartbeat sends SSE comment every 15 seconds
    - close() stops heartbeat and prevents further writes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent session manager with lifecycle and abort</name>
  <files>
    server/src/agent/session-manager.ts
  </files>
  <action>
    Create `server/src/agent/session-manager.ts` -- the core session lifecycle manager. This is the central orchestrator that Phase 13 will extend.

    1. Import dependencies:
       - `query` from `@anthropic-ai/claude-agent-sdk` (the async generator function)
       - `canUseTool` from `./tool-permissions.js`
       - Types from `./types.js`
       - `EventEmitter` from `events` (Node.js built-in)
       - `v4 as uuidv4` from `uuid` (already in server dependencies)

    2. Create `AgentSessionManager` class:
       a. Private `sessions: Map<string, AgentSession>` -- tracks all active sessions
       b. Private `projectSessions: Map<string, string>` -- maps projectId to sessionId (enforces one session per project, per user decision)

       c. `createSession(projectId: string, prompt: string, cwd: string): string`
          - Check if projectId already has an active session in `projectSessions`. If so, throw error "Project already has an active agent session".
          - Generate session ID with `uuidv4()`
          - Create `AbortController`
          - Create `AgentSession` object with state `'starting'`, store in both maps
          - Start the agent query in a detached async function (fire-and-forget pattern, matching existing codebase convention):
            * Call `query({ prompt, options: { cwd, abortController, includePartialMessages: true, permissionMode: 'default', canUseTool, disallowedTools: ['KillBash', 'NotebookEdit', 'ExitPlanMode', 'AskUserQuestion'], maxTurns: 50, maxBudgetUsd: 5.0, settingSources: [], systemPrompt: { type: 'preset', preset: 'claude_code', append: 'You are running as an automated agent. Do not ask questions. Complete the task autonomously.' } } })`
            * Set state to `'running'`
            * Iterate async generator: `for await (const message of agentQuery)`
            * Emit each message through an EventEmitter on the session for SSE forwarding
            * On successful completion: set state to `'completed'`
            * On abort (AbortError): set state to `'aborted'`
            * On error: set state to `'errored'`, log the error
            * In finally block: remove from `projectSessions` map
          - Return the session ID

       d. `getSession(sessionId: string): AgentSession | undefined`

       e. `abortSession(sessionId: string): boolean`
          - Find session, call `abortController.abort()`, return true/false

       f. `getActiveSessionForProject(projectId: string): AgentSession | undefined`
          - Look up in projectSessions map, return session if found

       g. `shutdownAll(reason: string): void`
          - For each active session: emit an 'interrupted' event through the session's EventEmitter, then abort
          - Used by graceful shutdown in app.ts
          - Mark all sessions as 'interrupted' (per user decision: interrupted sessions visible to user)

       h. `waitForAllCleanup(): Promise<void>`
          - Returns a promise that resolves when all sessions have finished their async generator iteration (or after a timeout)

       i. `cleanupOrphanedSessions(): void`
          - Called on startup. For this phase, just logs that startup cleanup ran. Actual orphan detection requires event store integration which is Phase 13+.

    3. Export a singleton: `export const agentSessionManager = new AgentSessionManager()`
    4. Also export the class for type reference: `export { AgentSessionManager }`

    Note: The `query()` API may have slightly different argument structure than researched. If `query` is not a named export or has a different call signature, adapt based on the SDK's actual TypeScript declarations. The core pattern (pass prompt + options, get async generator of messages) is stable per research.

    Note: The session's EventEmitter is how SSE clients will receive updates. Each session has its own emitter. The SSE route (Task 3) subscribes to the emitter and forwards events through the SSE writer.
  </action>
  <verify>
    1. `cd /Users/developer/eluma && npx tsc --noEmit` -- no type errors
    2. Verify exports: `cd /Users/developer/eluma && node --import tsx/esm -e "import { agentSessionManager } from './server/src/agent/session-manager.ts'; console.log('Session manager OK, type:', typeof agentSessionManager.createSession)"`
  </verify>
  <done>
    - server/src/agent/session-manager.ts exports agentSessionManager singleton and AgentSessionManager class
    - createSession enforces one session per project (throws on duplicate)
    - createSession calls query() with permissionMode: 'default', canUseTool handler, disallowedTools, maxTurns: 50, maxBudgetUsd: 5.0
    - abortSession calls AbortController.abort()
    - shutdownAll sends 'interrupted' event and aborts all sessions
    - waitForAllCleanup returns promise that resolves when all sessions finish
    - Sessions track state transitions: starting -> running -> completed/errored/aborted/interrupted
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire graceful shutdown and create test endpoint</name>
  <files>
    server/src/routes/agent.ts
    server/src/app.ts
  </files>
  <action>
    **Part A: Create test endpoint at server/src/routes/agent.ts**

    Create an Express router with two endpoints for verifying the full infrastructure works:

    1. `POST /test` -- Starts a test agent session:
       - Accept JSON body `{ prompt: string, projectId: string, cwd: string }`
       - Call `agentSessionManager.createSession(projectId, prompt, cwd)`
       - Return `{ success: true, sessionId }` with status 201
       - On error (duplicate session, etc.), return `{ success: false, error: message }` with status 400

    2. `GET /test/stream/:sessionId` -- SSE stream for a session:
       - Look up session via `agentSessionManager.getSession(sessionId)`
       - If not found, return 404 JSON error
       - Call `createSSEWriter(res)` to set up SSE response
       - Subscribe to session's EventEmitter for 'data' events, forward each through `sseWriter.send(event.type, event)`
       - On `req.on('close')`, call `sseWriter.close()` and unsubscribe from emitter
       - If session is already completed/errored, send the final status event and close

    3. `POST /test/abort/:sessionId` -- Aborts a session:
       - Call `agentSessionManager.abortSession(sessionId)`
       - Return success/failure

    Export the router as default.

    **Part B: Update server/src/app.ts**

    1. Add import: `import agentRouter from './routes/agent.js'`
    2. Add import: `import { agentSessionManager } from './agent/session-manager.js'`
    3. Register route: `app.use('/api/agent', requireAuth, agentRouter)` -- add after existing protected routes
    4. Update the `gracefulShutdown` function:
       - BEFORE `await stopMemoryWatcher()`, add:
         ```
         // Abort all active agent sessions and notify SSE clients
         agentSessionManager.shutdownAll('Server shutting down');
         // Wait for sessions to clean up (10s hard timeout)
         await Promise.race([
           agentSessionManager.waitForAllCleanup(),
           new Promise(resolve => setTimeout(resolve, 10_000)),
         ]);
         ```
       - Per user decision: grace period is 10 seconds, final SSE event sent to clients, interrupted sessions marked
    5. After the IIFE that sets up the Telegram bot, add on-startup orphan cleanup:
       ```
       agentSessionManager.cleanupOrphanedSessions();
       ```

    Keep all existing imports, routes, middleware, and error handling unchanged. Only ADD new lines.
  </action>
  <verify>
    1. `cd /Users/developer/eluma && npx tsc --noEmit` -- no type errors across all files
    2. Verify app.ts imports both agentRouter and agentSessionManager
    3. Verify gracefulShutdown calls agentSessionManager.shutdownAll before stopMemoryWatcher
    4. Verify route is registered: grep for '/api/agent' in app.ts
    5. Start the dev server briefly to confirm no startup crashes: `cd /Users/developer/eluma && timeout 10 node --env-file=.env --import tsx/esm server/src/index.ts 2>&1 || true` (should see "Eluma server running" before timeout)
  </verify>
  <done>
    - server/src/routes/agent.ts exports router with POST /test, GET /test/stream/:sessionId, POST /test/abort/:sessionId
    - server/src/app.ts imports and registers agent router at /api/agent (protected by requireAuth)
    - gracefulShutdown in app.ts aborts all agent sessions with 10s timeout before existing cleanup
    - Orphaned session cleanup runs on server startup
    - Full infrastructure is wired: SDK -> tool permissions -> session manager -> SSE writer -> route -> app.ts
  </done>
</task>

</tasks>

<verification>
**End-to-end verification (all 5 INFRA requirements):**

1. INFRA-01 (Agent SDK sessions): The test endpoint at POST /api/agent/test can create a session that calls query(). The session manager consumes the async generator.

2. INFRA-02 (PM2 memory): ecosystem.config.cjs has max_memory_restart: "1536M", node_args: "--max-old-space-size=2048", kill_timeout: 15000.

3. INFRA-03 (SSE streaming): GET /api/agent/test/stream/:sessionId returns Content-Type: text/event-stream. Every write calls res.flush(). Heartbeat pings every 15 seconds.

4. INFRA-04 (Tool permissions): canUseTool handler checks ALLOWED_TOOLS set. Dangerous Bash patterns blocked. Only rejections logged. permissionMode is 'default' (not bypassPermissions).

5. INFRA-05 (Graceful shutdown): SIGTERM triggers agentSessionManager.shutdownAll() which sends 'interrupted' SSE event, aborts all sessions, waits up to 10s for cleanup.

**TypeScript:** `npx tsc --noEmit` passes with zero errors.
**Server starts:** Dev server boots without crashes.
</verification>

<success_criteria>
1. SSE responses use res.flush() after every write, include sequential event IDs, send 15s heartbeat (INFRA-03 complete)
2. Session manager creates query() sessions with canUseTool, tracks state, enforces one-per-project (INFRA-01 complete)
3. Graceful shutdown aborts all sessions with 10s timeout, sends interrupt SSE event (INFRA-05 complete)
4. Test endpoints exist for manual verification of the full agent infrastructure
5. TypeScript compiles cleanly, server starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-infrastructure-safety/12-02-SUMMARY.md`
</output>
