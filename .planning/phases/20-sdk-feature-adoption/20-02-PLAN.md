---
phase: 20-sdk-feature-adoption
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - server/src/agent/session-recovery.ts
  - server/src/agent/session-manager.ts
  - server/src/agent/auth-check.ts
  - server/src/agent/warm-session.ts
  - server/src/app.ts
  - server/src/routes/agent.ts
  - client/src/hooks/useAgentStream.ts
  - client/src/components/AgentPanel.tsx
  - client/src/i18n/locales/en.json
  - client/src/i18n/locales/de.json
autonomous: true

must_haves:
  truths:
    - "After a server restart, previously paused sessions appear in the UI as resumable without the user re-creating them"
    - "At server startup, the log shows whether the auth token is valid including the account email and subscription type"
    - "If the auth token is invalid, the server still starts but logs a clear warning that agent sessions will fail"
    - "Session metadata is persisted to disk during graceful shutdown and on every pause, surviving server restarts"
  artifacts:
    - path: "server/src/agent/session-recovery.ts"
      provides: "loadPersistedSessions() and persistSessions() functions"
      exports: ["loadPersistedSessions", "persistSessions"]
    - path: "server/src/agent/auth-check.ts"
      provides: "verifyAuthToken() async function for live token validation"
      exports: ["checkAgentAuth", "verifyAuthToken"]
    - path: "server/src/agent/warm-session.ts"
      provides: "getAccountInfo() method on WarmAgentSession"
      contains: "getAccountInfo"
  key_links:
    - from: "server/src/agent/session-recovery.ts"
      to: "server/src/agent/session-manager.ts"
      via: "recoverSessions() calls loadPersistedSessions() at startup"
      pattern: "loadPersistedSessions"
    - from: "server/src/agent/session-manager.ts"
      to: "server/src/agent/session-recovery.ts"
      via: "pause() and cleanup() call persistSessions()"
      pattern: "persistSessions"
    - from: "server/src/agent/warm-session.ts"
      to: "server/src/agent/auth-check.ts"
      via: "verifyAuthToken() receives getAccountInfo callback"
      pattern: "verifyAuthToken"
    - from: "server/src/app.ts"
      to: "server/src/agent/auth-check.ts"
      via: "startup calls verifyAuthToken() after warm session ready"
      pattern: "verifyAuthToken"
---

<objective>
Add session recovery after server restart and auth token health check at startup.

Purpose: Currently, all paused sessions are lost when the server restarts (in-memory only). Users also have no early warning when their auth token is invalid -- they only find out when starting a session. This plan adds persistent session metadata and a live auth check.

Output: Sessions survive server restarts via `data/agent-sessions.json`. Auth token is validated against the SDK's `accountInfo()` API at startup with clear logging.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-sdk-feature-adoption/20-RESEARCH.md
@.planning/phases/20-sdk-feature-adoption/20-01-SUMMARY.md

@server/src/agent/session-manager.ts
@server/src/agent/auth-check.ts
@server/src/agent/warm-session.ts
@server/src/app.ts
@server/src/routes/agent.ts
@client/src/hooks/useAgentStream.ts
@client/src/components/AgentPanel.tsx
@client/src/i18n/locales/en.json
@client/src/i18n/locales/de.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session recovery module and integrate with session manager</name>
  <files>
    server/src/agent/session-recovery.ts
    server/src/agent/session-manager.ts
    server/src/app.ts
    server/src/routes/agent.ts
  </files>
  <action>
**1. Create `server/src/agent/session-recovery.ts`:**

```typescript
import { readFile, writeFile, mkdir } from "fs/promises";
import { join } from "path";

const SESSION_FILE = join(process.cwd(), "data", "agent-sessions.json");

export interface PersistedSessionInfo {
  projectId: string;
  sdkSessionId: string;
  userId: string;
  savedAt: string;
}
```

Implement two exported functions:

- `loadPersistedSessions(): Promise<PersistedSessionInfo[]>` -- reads the JSON file, returns parsed array. On any error (file missing, invalid JSON), return empty array with no error thrown. Log `[agent-recovery] Loaded N session(s) from disk` on success, or `[agent-recovery] No persisted sessions found` on empty/missing.

- `persistSessions(sessions: PersistedSessionInfo[]): Promise<void>` -- writes the array as formatted JSON to the file. Ensure the `data/` directory exists (use `mkdir(dirname, { recursive: true })` before writing). Log `[agent-recovery] Persisted N session(s) to disk`. On error, log a warning but do NOT throw.

**2. Update `server/src/agent/session-manager.ts`:**

Import `loadPersistedSessions`, `persistSessions`, and `PersistedSessionInfo` from `./session-recovery.js`.

Add a new public method `recoverSessions(): Promise<void>`:
- Call `loadPersistedSessions()`
- For each loaded session, create a `PausedSessionInfo` entry and add it to the `pausedSessions` Map keyed by `projectId`
- The `bufferSnapshot` for recovered sessions should be an empty array (no replay data persisted)
- Log `[agent] Recovered N resumable session(s) from previous run`

Update the `pause()` method: After adding to `pausedSessions`, call `this.persistCurrentSessions()` (a new private helper).

Update the `cleanup()` method: Before clearing paused sessions, call `await this.persistCurrentSessions()` to save any running sessions that were paused during shutdown. NOTE: `cleanup()` is currently sync. Change it to `async cleanup(): Promise<void>`. Also: before aborting running sessions, convert them to paused entries first (store their SDK session IDs as PersistedSessionInfo).

Add a private method `private async persistCurrentSessions(): Promise<void>`:
- Collect all entries from `pausedSessions` Map into a `PersistedSessionInfo[]`
- Call `persistSessions(entries)`

**IMPORTANT:** The `cleanup()` signature change from sync to async requires updating `app.ts` where it's called in `gracefulShutdown`. Add `await` before `agentSessions.cleanup()`.

**3. Update `server/src/app.ts`:**

Import nothing new -- `agentSessions` is already imported.

In the `warmSession.start().catch(...)` promise chain, add session recovery AFTER warm session starts:
```typescript
warmSession.start()
  .then(() => agentSessions.recoverSessions())
  .catch((err) => {
    console.error("[app] Failed to start warm agent session:", err instanceof Error ? err.message : String(err));
  });
```

In `gracefulShutdown`, change `agentSessions.cleanup()` to `await agentSessions.cleanup()` (cleanup is now async).

**4. Add a new route in `server/src/routes/agent.ts`:**

Add `GET /recoverable/:projectId` endpoint:
- Check auth (same pattern as other endpoints)
- Call `agentSessions.getPausedSession(projectId)`
- Return the paused session info if found and belongs to the user, or `null`

This is the same as the existing `GET /paused/:projectId` endpoint, so actually no new route is needed -- the existing paused endpoint already serves this purpose. Recovered sessions are loaded into the `pausedSessions` Map, so the existing route works.

However, add `GET /recoverable` (no projectId) to list ALL recoverable sessions for the user:
- Add a new public method to `AgentSessionManager`: `getRecoverableSessions(userId: string): PausedSessionInfo[]` that filters `pausedSessions` by userId
- Add the route that calls this and returns the filtered array
  </action>
  <verify>
Run `npm run build` from project root -- zero TypeScript errors. Verify `session-recovery.ts` exists with both functions. Verify `session-manager.ts` has `recoverSessions()` method. Verify `app.ts` calls `recoverSessions()` in the startup chain. Verify `cleanup()` is async and persists sessions before clearing.
  </verify>
  <done>
Session metadata persists to `data/agent-sessions.json` on pause and graceful shutdown. Sessions are recovered into the pausedSessions Map at server startup. Running sessions are converted to recoverable entries during graceful shutdown. Existing paused-session API endpoints serve recovered sessions without changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auth health check via accountInfo() and update client for recovered sessions</name>
  <files>
    server/src/agent/auth-check.ts
    server/src/agent/warm-session.ts
    server/src/app.ts
    client/src/components/AgentPanel.tsx
    client/src/i18n/locales/en.json
    client/src/i18n/locales/de.json
  </files>
  <action>
**1. Update `server/src/agent/warm-session.ts`:**

Add a public method `getAccountInfo()` to the `WarmAgentSession` class:

```typescript
/**
 * Get account info from the SDK. Requires the warm session to be started.
 * Uses the query instance's accountInfo() control method.
 */
async getAccountInfo(): Promise<Record<string, unknown>> {
  if (!this.started || !this.queryInstance) {
    throw new Error("[warm-session] Cannot get account info -- session not started");
  }
  // accountInfo() is a control method on the Query interface
  const info = await (this.queryInstance as any).accountInfo();
  return info;
}
```

NOTE: The `accountInfo()` method is on the Query interface but may not be in the TypeScript types yet. Use `(this.queryInstance as any).accountInfo()` to avoid type errors. If the SDK types DO include it, use the proper typed call instead.

Also, add a method to check if the session is ready:
```typescript
get isReady(): boolean {
  return this.started && !this.stopped;
}
```

**2. Update `server/src/agent/auth-check.ts`:**

Keep the existing `checkAgentAuth()` function unchanged.

Add a new exported async function `verifyAuthToken()`:

```typescript
/**
 * Verify the auth token is valid by calling the SDK's accountInfo().
 * Must be called AFTER warm session start (requires active Query instance).
 * Fire-and-forget: logs result but never throws.
 */
export async function verifyAuthToken(
  getAccountInfo: () => Promise<Record<string, unknown>>
): Promise<void> {
  try {
    const info = await getAccountInfo();
    const email = info.email as string | undefined;
    const subscriptionType = info.subscriptionType as string | undefined;
    const organization = info.organization as string | undefined;

    if (email) {
      console.log(
        `[agent-auth] Token verified: ${email}` +
        (subscriptionType ? ` (${subscriptionType})` : "") +
        (organization ? ` [${organization}]` : "")
      );
    } else {
      console.warn("[agent-auth] Token accepted but account details unavailable");
    }
  } catch (err) {
    console.error(
      "[agent-auth] Token verification FAILED:",
      err instanceof Error ? err.message : String(err),
      "-- Agent sessions will fail until auth is configured correctly"
    );
  }
}
```

**3. Update `server/src/app.ts`:**

Import `verifyAuthToken` from `./agent/auth-check.js`.

Update the warm session startup chain to include auth verification:
```typescript
warmSession.start()
  .then(async () => {
    // Recover sessions from previous run
    await agentSessions.recoverSessions();
    // Verify auth token is valid (fire-and-forget, logs result)
    if (warmSession.isReady) {
      await verifyAuthToken(() => warmSession.getAccountInfo());
    }
  })
  .catch((err) => {
    console.error("[app] Failed to start warm agent session:", err instanceof Error ? err.message : String(err));
  });
```

The auth check happens AFTER the warm session cold start completes, so the subprocess is ready. If the warm session fails to start, the auth check is skipped and the startup error is already logged.

**4. Update `client/src/components/AgentPanel.tsx`:**

The existing `checkPausedSession(projectId)` call in `useEffect` on mount already checks for paused sessions. Since recovered sessions are loaded into the same `pausedSessions` Map, the existing flow works. No changes needed to the check logic.

However, update the paused banner text to be more descriptive when a session is recovered (as opposed to manually paused). Since we cannot distinguish between the two at the API level (both are PausedSessionInfo), use the existing generic message. This is acceptable for v1.

**5. Update `client/src/i18n/locales/en.json`:**

Add these keys inside the `"agent"` object:
```json
"recovered_banner": "A previous session was recovered after server restart.",
"auth_status": "Auth Status"
```

Note: The `recovered_banner` key is for future use when we can distinguish recovered vs paused sessions. For now the existing `paused_banner` is used for both.

**6. Update `client/src/i18n/locales/de.json`:**

Add the matching German keys inside the `"agent"` object:
```json
"recovered_banner": "Eine vorherige Sitzung wurde nach dem Serverneustart wiederhergestellt.",
"auth_status": "Auth-Status"
```

IMPORTANT: Use proper Unicode umlauts -- `ü` in `Serverneustart`, `ä` in `wiederhergestellt`. These are already correct above.
  </action>
  <verify>
Run `npm run build` from project root -- zero TypeScript errors. Verify `warm-session.ts` has `getAccountInfo()` and `isReady` getter. Verify `auth-check.ts` exports `verifyAuthToken`. Verify `app.ts` startup chain includes both `recoverSessions()` and `verifyAuthToken()`. Check both i18n files have the new keys.
  </verify>
  <done>
Auth token is validated at startup via accountInfo() with clear log output. Server logs show email and subscription type on success, or a clear warning on failure. Server always starts regardless of auth result. Session recovery and auth check happen sequentially in the startup chain after warm session cold start.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes with zero TypeScript errors
2. `ls data/agent-sessions.json` -- file created after first pause or shutdown (may not exist initially)
3. Server startup logs show `[agent-auth] Token verified: ...` or `[agent-auth] Token verification FAILED: ...`
4. Server startup logs show `[agent-recovery] Loaded N session(s)` or `[agent-recovery] No persisted sessions found`
5. After pausing a session and restarting the server, the paused session endpoint returns the recovered session
6. `grep "verifyAuthToken" server/src/app.ts` confirms the call is present
7. `grep "recoverSessions" server/src/app.ts` confirms the call is present
8. Both `en.json` and `de.json` have `recovered_banner` and `auth_status` keys
</verification>

<success_criteria>
- Session metadata is written to `data/agent-sessions.json` on every pause and during graceful shutdown
- At server startup, persisted sessions are loaded and available via the existing paused-session API
- Auth health check runs after warm session start and logs the account email/subscription type
- Invalid tokens produce a clear warning log but do not prevent server startup
- Running sessions are converted to recoverable entries during graceful shutdown (not silently lost)
- Zero TypeScript build errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-sdk-feature-adoption/20-02-SUMMARY.md`
</output>
