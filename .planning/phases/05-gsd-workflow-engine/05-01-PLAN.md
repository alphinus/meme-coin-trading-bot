---
phase: 05-gsd-workflow-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/workflow.ts
  - shared/types/events.ts
  - shared/types/ai.ts
  - server/src/workflow/types.ts
  - server/src/workflow/definitions.ts
  - server/src/workflow/engine.ts
  - server/src/workflow/context.ts
  - server/src/events/reducers/workflow.ts
  - server/src/routes/workflow.ts
autonomous: true

must_haves:
  truths:
    - "Workflow step definitions exist for all 8 lifecycle phases"
    - "Workflow engine can complete a step, resolve the next step, and detect phase completion"
    - "Workflow state is event-sourced from JSONL events via reducer"
    - "Decision point Go/No-Go/Defer branching is defined with correct next-step routing"
    - "API endpoints serve workflow state and accept step completions"
  artifacts:
    - path: "shared/types/workflow.ts"
      provides: "StepType, WorkflowStepDef, WorkflowOption, WorkflowState, WorkflowStepResult types"
      exports: ["StepType", "WorkflowStepDef", "WorkflowOption", "WorkflowState", "WorkflowStepResult", "WorkflowAdvanceResult"]
    - path: "server/src/workflow/definitions.ts"
      provides: "Step definitions for all 8 lifecycle phases"
      exports: ["getStepsForPhase", "getStepDefinition", "getAllStepDefinitions"]
    - path: "server/src/workflow/engine.ts"
      provides: "Core workflow progression logic"
      exports: ["completeWorkflowStep", "getWorkflowState", "initializeWorkflowForProject"]
    - path: "server/src/events/reducers/workflow.ts"
      provides: "Workflow state reducer from JSONL events"
      exports: ["reduceWorkflowState"]
    - path: "server/src/routes/workflow.ts"
      provides: "GET /:projectId and POST /:projectId/step API endpoints"
  key_links:
    - from: "server/src/workflow/engine.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for workflow.step_completed and workflow.pipeline_entered events"
      pattern: "appendEvent.*workflow\\."
    - from: "server/src/workflow/engine.ts"
      to: "server/src/events/reducers/project.ts"
      via: "getProjectById to derive currentPhase, getNextPhase for advancement"
      pattern: "getProjectById|getNextPhase"
    - from: "server/src/workflow/engine.ts"
      to: "server/src/routes/projects.ts advance logic"
      via: "Calls existing phase advance mechanism (appendEvent phase_completed + phase_advanced)"
      pattern: "project\\.phase_completed|project\\.phase_advanced"
    - from: "server/src/routes/workflow.ts"
      to: "server/src/workflow/engine.ts"
      via: "Route handlers call engine functions"
      pattern: "completeWorkflowStep|getWorkflowState"
---

<objective>
Build the complete server-side workflow engine: shared types, step definitions for all 8 lifecycle phases, event-sourced workflow state reducer, workflow progression engine, and REST API routes.

Purpose: This plan establishes the server-authoritative workflow data model and logic. The workflow engine defines sub-steps within each lifecycle phase, manages progression through steps, handles decision_point branching (Go/No-Go/Defer), and bridges to the existing phase advancement mechanism. All workflow state is event-sourced via the existing JSONL store.

Output: Shared workflow types, server workflow module (definitions, engine, context, reducer), workflow API routes.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gsd-workflow-engine/05-RESEARCH.md

# Source files for integration
@shared/types/events.ts
@shared/types/models.ts
@shared/types/ai.ts
@shared/types/api.ts
@server/src/events/store.ts
@server/src/events/reducers/project.ts
@server/src/routes/projects.ts
@server/src/ai/generate.ts
@server/src/middleware/validate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared workflow types and extend event types</name>
  <files>
    shared/types/workflow.ts
    shared/types/events.ts
    shared/types/ai.ts
  </files>
  <action>
    Create `shared/types/workflow.ts` with the following types (reference research for detailed interfaces):

    1. **StepType** union: `"button_choice" | "text_input" | "info_display" | "ai_prompt" | "auto_advance"`

    2. **WorkflowStepDef** interface:
       - `id: string` (unique step ID within phase, e.g., "idea_describe")
       - `phase: ProjectPhase` (which lifecycle phase)
       - `order: number` (sequence within phase, 0-indexed)
       - `type: StepType`
       - `titleKey: string` (i18n key for step title)
       - `descriptionKey?: string` (i18n key for description/guidance)
       - `options?: WorkflowOption[]` (for button_choice)
       - `textConfig?: { placeholderKey: string; minLength?: number; maxLength?: number; fieldKey: string }` (for text_input -- fieldKey maps to where the response is stored in phaseData)
       - `aiConfig?: { taskType: AiTaskType; promptTemplate: string }` (for ai_prompt)
       - `required: boolean`
       - `nextStepCondition?: { field: string; routes: Record<string, string> }` (conditional branching)

    3. **WorkflowOption** interface:
       - `value: string`
       - `labelKey: string` (i18n key)
       - `variant?: "primary" | "secondary" | "danger"` (button styling hint)

    4. **WorkflowState** interface:
       - `projectId: string`
       - `currentPhase: ProjectPhase` (derived from project state, not stored independently)
       - `currentStepId: string`
       - `completedSteps: Record<string, WorkflowStepResult>` (stepId -> result)
       - `enteredPipeline: boolean` (passed Decision Point with "Go")
       - `pipelineEnteredAt?: string` (ISO timestamp)

    5. **WorkflowStepResult** interface:
       - `stepId: string`
       - `type: StepType`
       - `response: Record<string, unknown>`
       - `completedAt: string`
       - `completedBy: string` (userId)

    6. **WorkflowAdvanceResult** discriminated union:
       - `{ type: "next_step"; stepId: string; step: WorkflowStepDef }`
       - `{ type: "phase_advanced"; nextPhase: ProjectPhase; firstStep: WorkflowStepDef }`
       - `{ type: "lifecycle_complete" }`
       - `{ type: "project_archived"; reason: string }` (for No-Go archival)
       - `{ type: "project_deferred" }` (for Defer at decision point)

    Import `ProjectPhase` from `shared/types/models.js` and `AiTaskType` from `shared/types/ai.js`.

    Then extend `shared/types/events.ts`:
    - Add to EventType union: `"workflow.step_completed"`, `"workflow.pipeline_entered"`, `"workflow.context_reset"`
    - Add same three strings to EVENT_TYPES const array

    Then extend `shared/types/ai.ts`:
    - Add `"workflow_guidance"` to the AiTaskType union (for AI-guided workflow steps)
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root. All new types compile without errors. Grep for "workflow.step_completed" in events.ts to confirm event types added.
  </verify>
  <done>
    shared/types/workflow.ts exports all workflow types. events.ts includes 3 new workflow event types. ai.ts includes workflow_guidance task type. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build server workflow module (definitions, engine, reducer, routes)</name>
  <files>
    server/src/workflow/types.ts
    server/src/workflow/definitions.ts
    server/src/workflow/engine.ts
    server/src/workflow/context.ts
    server/src/events/reducers/workflow.ts
    server/src/routes/workflow.ts
  </files>
  <action>
    **A. Create `server/src/workflow/types.ts`** -- Internal server-only types:
    - Re-export shared types from `shared/types/workflow.js` for convenience
    - Add any server-internal types if needed (likely just re-exports)

    **B. Create `server/src/events/reducers/workflow.ts`** -- Event-sourced workflow state reducer:
    - Follow the exact pattern of `server/src/events/reducers/project.ts`
    - `reduceWorkflowState(events: DomainEvent[]): WorkflowState | null` -- reduces workflow events for a single project
    - Handle event types: `workflow.step_completed` (add to completedSteps), `workflow.pipeline_entered` (set enteredPipeline + timestamp), `workflow.context_reset` (clear completedSteps for a phase, used on re-entry)
    - `getWorkflowEventsForProject(projectId: string)` -- reads events from "workflow" aggregate type with projectId as aggregateId
    - The reducer derives `currentStepId` by finding the first uncompleted required step in the current phase's step definitions (import from definitions.ts)
    - If no workflow events exist for a project, return a default initial state with the project's current phase's first step as currentStepId. This handles legacy projects gracefully.

    **C. Create `server/src/workflow/definitions.ts`** -- Step definitions for all 8 phases:
    - Export `getStepsForPhase(phase: ProjectPhase): WorkflowStepDef[]`
    - Export `getStepDefinition(stepId: string): WorkflowStepDef | undefined`
    - Export `getAllStepDefinitions(): WorkflowStepDef[]`
    - Define step arrays for each phase. Each phase gets 3-5 steps. Keep steps simple. Specific steps:

      **idea** (3 steps):
      1. `idea_describe` -- text_input: describe the core idea (fieldKey: "core_idea")
      2. `idea_problem` -- text_input: what problem does it solve (fieldKey: "problem")
      3. `idea_confirm` -- button_choice: "Ready to proceed" (primary) / "Need more time" (secondary)

      **feasibility** (3 steps):
      1. `feas_technical` -- text_input: technical feasibility assessment (fieldKey: "technical_feasibility")
      2. `feas_resources` -- text_input: resource availability (fieldKey: "resource_availability")
      3. `feas_verdict` -- button_choice: "Feasible" (primary) / "Concerns exist" (secondary)

      **effort_estimate** (3 steps):
      1. `effort_hours` -- text_input: estimated hours (fieldKey: "estimated_hours")
      2. `effort_cost` -- text_input: estimated cost (fieldKey: "estimated_cost")
      3. `effort_confirm` -- button_choice: "Estimates complete" (primary)

      **roi_kpi_initial** (3 steps):
      1. `roi_impact` -- text_input: expected revenue/savings impact (fieldKey: "expected_revenue_impact")
      2. `roi_metrics` -- text_input: success metrics (fieldKey: "success_metrics")
      3. `roi_confirm` -- button_choice: "KPIs defined" (primary)

      **risks_dependencies** (3 steps):
      1. `risk_identify` -- text_input: identified risks (fieldKey: "identified_risks")
      2. `risk_deps` -- text_input: dependencies (fieldKey: "dependencies")
      3. `risk_mitigation` -- text_input: mitigation strategies (fieldKey: "mitigation_strategies")

      **decision_point** (4 steps with branching):
      1. `dp_summary` -- info_display: review summary of all prior phase data
      2. `dp_go_nogo` -- button_choice: "Go" (primary) / "No-Go" (danger) / "Defer" (secondary), with nextStepCondition routing: go -> dp_go_confirm, nogo -> dp_nogo_rationale, defer -> dp_defer_reason
      3. `dp_go_confirm` -- button_choice: "Confirm Go" (primary) / "Go back" (secondary)
      4. `dp_nogo_rationale` -- text_input: no-go rationale (fieldKey: "nogo_rationale")
      5. `dp_defer_reason` -- text_input: defer reason (fieldKey: "defer_reason")

      **implementation** (4 steps):
      1. `impl_start` -- info_display: "Implementation phase started. Track progress below."
      2. `impl_progress` -- text_input: progress notes (fieldKey: "progress_notes")
      3. `impl_blockers` -- text_input: blockers (fieldKey: "blockers")
      4. `impl_complete` -- button_choice: "Implementation complete" (primary)

      **review_extraction** (4 steps):
      1. `review_learnings` -- text_input: key learnings (fieldKey: "key_learnings")
      2. `review_replicate` -- text_input: patterns to replicate (fieldKey: "patterns_replicate")
      3. `review_avoid` -- text_input: patterns to avoid (fieldKey: "patterns_avoid")
      4. `review_complete` -- button_choice: "Complete review & archive" (primary)

    All titleKey and descriptionKey values follow the pattern `workflow.{phase}.{step_suffix}` for i18n.

    **D. Create `server/src/workflow/engine.ts`** -- Core workflow progression logic:
    - Import: `appendEvent` from events/store, `getProjectById`, `getNextPhase`, `getCurrentVersion` from reducers/project, `getWorkflowEventsForProject` + `reduceWorkflowState` from reducers/workflow, `getStepsForPhase`, `getStepDefinition` from definitions, `processEventForDocumentation` from docs/writer, `evaluateTriggersForEvent` from ai/triggers/engine
    - `getWorkflowState(projectId: string): Promise<WorkflowState>`:
      1. Read workflow events via `getWorkflowEventsForProject(projectId)`
      2. Read project state via `getProjectById(projectId)` to get currentPhase
      3. Reduce workflow events to state
      4. If null (no workflow events), initialize default state with currentPhase's first step
      5. Ensure state.currentPhase matches project's currentPhase (project reducer is single source of truth)
    - `completeWorkflowStep(projectId, stepId, response, userId): Promise<WorkflowAdvanceResult>`:
      1. Get step definition; validate it exists
      2. Get current workflow state; validate stepId matches currentStepId (idempotency: if step already completed, return existing result)
      3. Append `workflow.step_completed` event (aggregateType: "workflow", aggregateId: projectId)
      4. Fire-and-forget processEventForDocumentation + evaluateTriggersForEvent on the event
      5. Resolve next step via `resolveNextStep`:
         - If step has nextStepCondition, route based on response[field]
         - Otherwise, find next step by order
         - If no more steps in phase, return "__phase_complete__"
      6. If `__phase_complete__`:
         - Aggregate all step responses into phaseData (merge all response objects, using fieldKey where available)
         - Special handling for decision_point phase:
           - If Go was selected: call existing advance mechanism (append project.phase_completed + project.phase_advanced events using same pattern as routes/projects.ts advance endpoint), then append `workflow.pipeline_entered` event, return `{ type: "phase_advanced", nextPhase, firstStep }`
           - If No-Go: append project.phase_completed, then append project.archived event with reason "nogo_decision", return `{ type: "project_archived", reason: "nogo" }`
           - If Defer: append project.phase_completed event only (project stays at decision_point), return `{ type: "project_deferred" }`
         - For other phases: call existing advance mechanism, return phase_advanced or lifecycle_complete as appropriate
      7. If next step exists: return `{ type: "next_step", stepId, step }`
    - `initializeWorkflowForProject(projectId: string): Promise<WorkflowState>` -- called when loading workflow for first time; returns default state based on project's currentPhase

    **E. Create `server/src/workflow/context.ts`** -- Context management (invisible operations):
    - `aggregateStepResponses(completedSteps: Record<string, WorkflowStepResult>, phase: ProjectPhase): Record<string, unknown>`:
      1. Get step definitions for the phase
      2. For each completed step, extract the response values
      3. For text_input steps: use the fieldKey from textConfig to map to phaseData keys
      4. For button_choice steps: store as the step's fieldKey or step id
      5. Return merged phaseData object
    - This is the invisible "context management" that GSD-04 requires -- aggregating step data into phase data happens behind the scenes.

    **F. Create `server/src/routes/workflow.ts`** -- API endpoints:
    - Follow the exact pattern of existing routes (Express Router, Zod validation, ApiResponse wrapper, team ownership verification)
    - `GET /api/workflow/:projectId` -- returns `{ state: WorkflowState, steps: WorkflowStepDef[], currentPhase: ProjectPhase }`
      1. Get project by ID (404 if not found)
      2. Verify team ownership (same pattern as projects.ts)
      3. Get workflow state via engine.getWorkflowState
      4. Get step definitions for current phase
      5. Return state + steps + currentPhase
    - `POST /api/workflow/:projectId/step` -- complete a step
      1. Validate body with Zod: `{ stepId: string, response: Record<string, unknown> }`
      2. Get project (404 if not found), verify team ownership, check not archived
      3. Call engine.completeWorkflowStep
      4. Return the WorkflowAdvanceResult
    - Use `req.user!.id` for userId (same pattern as all other routes)
    - Import validate middleware from `../middleware/validate.js`
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root. All workflow module files compile without errors. Verify workflow route exports default Router. Verify engine.ts imports from existing modules (store, reducers, docs, triggers) resolve correctly.
  </verify>
  <done>
    Complete server workflow module: definitions for all 8 phases with 3-5 steps each, event-sourced reducer, engine with step completion and phase advancement logic (including decision_point Go/No-Go/Defer branching), context aggregation, and REST API routes. TypeScript compiles cleanly. The workflow engine calls the existing phase advance mechanism and does not replace it.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `shared/types/workflow.ts` exports StepType, WorkflowStepDef, WorkflowOption, WorkflowState, WorkflowStepResult, WorkflowAdvanceResult
3. `shared/types/events.ts` includes workflow.step_completed, workflow.pipeline_entered, workflow.context_reset
4. `server/src/workflow/definitions.ts` returns step arrays for all 8 PROJECT_PHASES values
5. `server/src/workflow/engine.ts` exports completeWorkflowStep and getWorkflowState
6. `server/src/routes/workflow.ts` exports a Router with GET /:projectId and POST /:projectId/step
</verification>

<success_criteria>
- All shared and server workflow files exist and compile
- Step definitions cover all 8 phases with button_choice, text_input, info_display types
- Decision point has Go/No-Go/Defer branching with correct routing
- Workflow state is derived from JSONL events (not stored mutably)
- Engine bridges to existing phase advancement without replacing it
- Legacy projects (no workflow events) get a default initial state
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-workflow-engine/05-01-SUMMARY.md`
</output>
