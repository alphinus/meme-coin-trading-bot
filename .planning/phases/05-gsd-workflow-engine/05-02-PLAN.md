---
phase: 05-gsd-workflow-engine
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - client/src/components/workflow/WorkflowEngine.tsx
  - client/src/components/workflow/StepButton.tsx
  - client/src/components/workflow/StepTextInput.tsx
  - client/src/components/workflow/StepInfoDisplay.tsx
  - client/src/components/workflow/StepAiPrompt.tsx
  - client/src/components/workflow/StepProgress.tsx
  - client/src/hooks/useWorkflow.ts
autonomous: true

must_haves:
  truths:
    - "Button choice steps render as styled, clickable buttons with double-click prevention"
    - "Text input steps render a textarea only when the workflow step type is text_input"
    - "Info display steps render markdown guidance with a single Continue button"
    - "WorkflowEngine renders the correct component based on current step type"
    - "useWorkflow hook fetches workflow state, exposes completeStep, and refreshes after completion"
    - "Step progress indicator shows which step the user is on within the current phase"
  artifacts:
    - path: "client/src/components/workflow/StepButton.tsx"
      provides: "Button choice step component with variant-styled buttons"
      exports: ["StepButton"]
    - path: "client/src/components/workflow/StepTextInput.tsx"
      provides: "Freeform text input step with validation"
      exports: ["StepTextInput"]
    - path: "client/src/components/workflow/StepInfoDisplay.tsx"
      provides: "Read-only info display step with Continue button"
      exports: ["StepInfoDisplay"]
    - path: "client/src/components/workflow/StepAiPrompt.tsx"
      provides: "AI-guided step with AI response rendering"
      exports: ["StepAiPrompt"]
    - path: "client/src/components/workflow/StepProgress.tsx"
      provides: "Visual step progress indicator within current phase"
      exports: ["StepProgress"]
    - path: "client/src/components/workflow/WorkflowEngine.tsx"
      provides: "Main workflow container that dispatches to step components"
      exports: ["WorkflowEngine"]
    - path: "client/src/hooks/useWorkflow.ts"
      provides: "Client-side workflow state management hook"
      exports: ["useWorkflow"]
  key_links:
    - from: "client/src/hooks/useWorkflow.ts"
      to: "/api/workflow/:projectId"
      via: "apiCall GET and POST for workflow state and step completion"
      pattern: "apiCall.*api/workflow"
    - from: "client/src/components/workflow/WorkflowEngine.tsx"
      to: "client/src/hooks/useWorkflow.ts"
      via: "useWorkflow hook provides state and completeStep"
      pattern: "useWorkflow"
    - from: "client/src/components/workflow/WorkflowEngine.tsx"
      to: "Step components (StepButton, StepTextInput, StepInfoDisplay, StepAiPrompt)"
      via: "switch on step.type renders appropriate component"
      pattern: "case.*button_choice|text_input|info_display|ai_prompt"
---

<objective>
Build all client-side workflow components: the useWorkflow hook for state management, five step-type components (StepButton, StepTextInput, StepInfoDisplay, StepAiPrompt, StepProgress), and the WorkflowEngine container that orchestrates them.

Purpose: These components implement the button-driven UI that non-techies can navigate (GSD-02, GSD-03, GSD-05). Button choices are the default interaction pattern; text input appears only when the workflow step explicitly requires it; info displays provide guidance between actions.

Output: Complete client-side workflow component library and hook, ready for integration into ProjectDetail page.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gsd-workflow-engine/05-RESEARCH.md
@.planning/phases/05-gsd-workflow-engine/05-01-SUMMARY.md

# Source files for patterns
@shared/types/workflow.ts
@client/src/hooks/useProject.ts
@client/src/api/client.ts
@client/src/hooks/useLanguage.ts
@client/src/components/PhaseContent.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useWorkflow hook and step-type components</name>
  <files>
    client/src/hooks/useWorkflow.ts
    client/src/components/workflow/StepButton.tsx
    client/src/components/workflow/StepTextInput.tsx
    client/src/components/workflow/StepInfoDisplay.tsx
    client/src/components/workflow/StepAiPrompt.tsx
    client/src/components/workflow/StepProgress.tsx
  </files>
  <action>
    **A. Create `client/src/hooks/useWorkflow.ts`:**
    Follow the exact pattern of `useProject.ts` (useState, useEffect, useCallback).
    - `useWorkflow(projectId: string | undefined)` returns:
      - `workflowState: WorkflowState | null`
      - `steps: WorkflowStepDef[]` (all steps for current phase)
      - `currentStep: WorkflowStepDef | null` (the active step)
      - `currentPhase: ProjectPhase | null`
      - `loading: boolean`
      - `error: string | null`
      - `completeStep: (stepId: string, response: Record<string, unknown>) => Promise<WorkflowAdvanceResult | null>`
      - `refresh: () => Promise<void>`
    - `fetchWorkflow`: GET `/api/workflow/${projectId}`, sets data state
    - `completeStep`: POST `/api/workflow/${projectId}/step` with `{ stepId, response }`, then calls fetchWorkflow to refresh state. Returns the advance result.
    - `currentStep`: derived as `steps.find(s => s.id === workflowState?.currentStepId) ?? null`
    - Import apiCall from `../api/client.js`, types from `shared/types/workflow.js`, ProjectPhase from `shared/types/models.js`

    **B. Create `client/src/components/workflow/StepButton.tsx`:**
    Renders a button_choice step as a grid of styled buttons.
    - Props: `{ step: WorkflowStepDef; onSelect: (response: Record<string, unknown>) => Promise<void> }`
    - Use `useLanguage` hook for `t()` function
    - Render step title via `t(step.titleKey)`, optional description via `t(step.descriptionKey)`
    - Render `step.options` as buttons in a flex-wrap container with 0.75rem gap
    - Each button calls `onSelect({ [step.id]: option.value, selectedOption: option.value })`
    - **Double-click prevention**: `const [selecting, setSelecting] = useState(false)` -- set true on click, disable all buttons, reset in finally block
    - Button styling by variant:
      - primary: backgroundColor `#10b981`, color `#fff`
      - danger: backgroundColor `#ef4444`, color `#fff`
      - secondary: backgroundColor `#f3f4f6`, color `#374151`, border `1px solid #d1d5db`
      - Default to primary if variant not specified
    - Button padding: `0.75rem 1.5rem`, fontSize `1rem`, fontWeight 600, borderRadius `8px`
    - Disabled state: opacity 0.6, cursor not-allowed

    **C. Create `client/src/components/workflow/StepTextInput.tsx`:**
    Renders a text_input step with a textarea and Submit button.
    - Props: `{ step: WorkflowStepDef; onSubmit: (response: Record<string, unknown>) => Promise<void> }`
    - Use `useLanguage` hook for translations
    - Render title, optional description
    - Textarea with placeholder from `t(step.textConfig.placeholderKey)`
    - **Validation**: if `step.textConfig.minLength`, disable Submit button until text meets minimum. If `step.textConfig.maxLength`, limit textarea maxLength attribute.
    - On submit: `onSubmit({ [step.textConfig.fieldKey]: textValue.trim() })`
    - Submit button: primary style, disabled while submitting (useState submitting flag)
    - Textarea uses same styling as PhaseContent textarea (padding 0.5rem, border 1px solid #d1d5db, borderRadius 6px, resize vertical, fontFamily inherit)

    **D. Create `client/src/components/workflow/StepInfoDisplay.tsx`:**
    Renders info text (optionally markdown) with a single Continue button.
    - Props: `{ step: WorkflowStepDef; onContinue: (response: Record<string, unknown>) => Promise<void> }`
    - Render title, description text (plain text via `t()`, not markdown -- keep it simple for v1)
    - Single "Continue" button (primary variant styling)
    - On continue: `onContinue({ acknowledged: true })`
    - Info box styling: backgroundColor `#f9fafb`, border `1px solid #e5e7eb`, borderRadius `8px`, padding `1rem`

    **E. Create `client/src/components/workflow/StepAiPrompt.tsx`:**
    Renders an AI-guided step. For v1, this is a simplified version: shows step title/description, a "Get AI Guidance" button that calls the workflow step completion (which triggers AI generation server-side), and displays the response.
    - Props: `{ step: WorkflowStepDef; onRespond: (response: Record<string, unknown>) => Promise<void> }`
    - State: `generating: boolean`, `aiResponse: string | null`
    - On "Get AI Guidance" click: `onRespond({ requested: true })` -- the server-side engine handles AI generation
    - Display: title, description, button, and after response is returned, show a text area for the user to acknowledge/respond
    - For v1, keep this simple -- the full AI integration will be exercised when projects actually reach AI-prompt steps. The component structure is the important part.

    **F. Create `client/src/components/workflow/StepProgress.tsx`:**
    Visual progress indicator showing current step position within the phase.
    - Props: `{ steps: WorkflowStepDef[]; currentStepId: string; completedStepIds: string[] }`
    - Render as a horizontal sequence of small circles/dots:
      - Completed steps: solid green (#10b981) circle
      - Current step: solid blue (#2563eb) circle with slight scale/ring
      - Future steps: gray (#d1d5db) circle
    - Below dots, show "Step {current} of {total}" text
    - Use flexbox with gap, centered alignment
    - Circle size: 10px diameter, with 12px for current step
    - Style is clean and minimal (matches the "calm, not playful" UI guideline from PROJECT.md)
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root. All new component and hook files compile. Verify StepButton has selecting state for double-click prevention. Verify StepTextInput conditionally renders based on textConfig. Verify useWorkflow matches useProject pattern.
  </verify>
  <done>
    useWorkflow hook fetches and manages workflow state via API. All 5 step-type components render the correct UI for their type. StepButton prevents double-clicks. StepTextInput only appears when step type is text_input. StepInfoDisplay shows guidance with Continue. StepProgress visualizes position within phase steps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowEngine container component</name>
  <files>
    client/src/components/workflow/WorkflowEngine.tsx
  </files>
  <action>
    Create the main WorkflowEngine container that orchestrates all step components.

    **Props:**
    ```typescript
    interface WorkflowEngineProps {
      projectId: string;
      project: ProjectState;
      onPhaseAdvanced: () => void;  // Callback to refresh project state in parent
    }
    ```

    **Component logic:**
    1. Call `useWorkflow(projectId)` to get workflow state, steps, currentStep, completeStep, loading, error
    2. Define `handleStepComplete` async function:
       - Calls `completeStep(stepId, response)`
       - Handles the WorkflowAdvanceResult:
         - `next_step`: workflow auto-refreshes via hook (no action needed)
         - `phase_advanced`: call `onPhaseAdvanced()` to refresh parent's project state
         - `lifecycle_complete`: call `onPhaseAdvanced()` (project will show as archived)
         - `project_archived`: call `onPhaseAdvanced()`
         - `project_deferred`: show a brief info message, call `onPhaseAdvanced()`
    3. Render structure:
       - If loading: show centered loading text (same pattern as ProjectDetail)
       - If error: show error message in red
       - If currentStep is null: show "All steps completed" info message
       - Otherwise:
         - StepProgress at the top (shows position within phase)
         - Then the appropriate step component via switch on `currentStep.type`:
           - `button_choice` -> `<StepButton step={currentStep} onSelect={handleStepComplete} />`
           - `text_input` -> `<StepTextInput step={currentStep} onSubmit={handleStepComplete} />`
           - `info_display` -> `<StepInfoDisplay step={currentStep} onContinue={handleStepComplete} />`
           - `ai_prompt` -> `<StepAiPrompt step={currentStep} onRespond={handleStepComplete} />`
           - `auto_advance` -> null (auto_advance steps are handled server-side, client never renders them)
           - default -> `<StepInfoDisplay step={currentStep} onContinue={handleStepComplete} />` (safe fallback)

    **Styling:**
    - Container: no extra chrome -- it slots into the existing ProjectDetail card layout
    - Transition between steps: simple opacity fade (0.3s) using a key prop on the step container keyed by currentStep.id. This prevents jarring content swaps.
    - The container should have a min-height to prevent layout shift during transitions

    **Important:** Do NOT import or use PhaseContent or PhaseManagement. WorkflowEngine replaces PhaseContent for the active phase. The parent (ProjectDetail, wired in Plan 03) decides whether to show WorkflowEngine or PhaseContent.
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root. WorkflowEngine compiles. Verify it imports all 5 step components. Verify it handles all WorkflowAdvanceResult types. Verify switch covers all StepType values.
  </verify>
  <done>
    WorkflowEngine component renders the current workflow step using the appropriate sub-component based on step type, handles step completion results including phase advancement and project archival, and provides visual step progress. Ready for integration into ProjectDetail page.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 7 new client files exist and export their named components/hooks
3. useWorkflow follows useProject pattern (useState, useCallback, useEffect)
4. StepButton has double-click prevention (selecting state)
5. StepTextInput respects textConfig validation (minLength, maxLength)
6. WorkflowEngine switch covers all StepType values
7. StepProgress renders completed/current/future step indicators
</verification>

<success_criteria>
- All client workflow components compile and export correctly
- Button choices render with variant-appropriate styling
- Text input appears only for text_input step type
- WorkflowEngine dispatches to correct component per step type
- useWorkflow hook manages API calls to /api/workflow/:projectId
- Components follow existing codebase conventions (inline styles, useLanguage, apiCall pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-workflow-engine/05-02-SUMMARY.md`
</output>
