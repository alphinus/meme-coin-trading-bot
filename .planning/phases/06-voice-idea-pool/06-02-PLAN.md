---
phase: 06-voice-idea-pool
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - server/src/voice/router-analysis.ts
  - server/src/idea-pool/refinement.ts
  - server/src/idea-pool/graduation.ts
  - server/src/routes/ideas.ts
  - server/src/routes/voice.ts
autonomous: true

must_haves:
  truths:
    - "AI analyzes transcribed text and suggests which existing project it belongs to (or Idea Pool for new ideas)"
    - "AI generates a focused refinement question targeting the biggest gap in idea readiness"
    - "AI assesses readiness with a 0-100 score based on problem statement, audience, feasibility, and effort"
    - "Ideas can be proposed for graduation and team members can vote approve/reject"
    - "When all team members approve, the idea graduates to a new project"
  artifacts:
    - path: "server/src/voice/router-analysis.ts"
      provides: "analyzeVoiceRouting function that suggests project or Idea Pool"
      exports: ["analyzeVoiceRouting"]
    - path: "server/src/idea-pool/refinement.ts"
      provides: "generateRefinementQuestion and assessReadiness functions"
      exports: ["generateRefinementQuestion", "assessReadiness"]
    - path: "server/src/idea-pool/graduation.ts"
      provides: "proposeGraduation, voteOnGraduation, and executeGraduation functions"
      exports: ["proposeGraduation", "voteOnGraduation", "executeGraduation"]
  key_links:
    - from: "server/src/voice/router-analysis.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse with taskType voice_routing"
      pattern: "generateAiResponse.*voice_routing"
    - from: "server/src/idea-pool/refinement.ts"
      to: "server/src/ai/generate.ts"
      via: "generateAiResponse with taskType idea_refinement and idea_readiness"
      pattern: "generateAiResponse.*idea_refinement|idea_readiness"
    - from: "server/src/idea-pool/graduation.ts"
      to: "server/src/events/store.ts"
      via: "appendEvent for project.created and idea.graduated"
      pattern: "appendEvent.*project\\.created|idea\\.graduated"
    - from: "server/src/routes/ideas.ts"
      to: "server/src/idea-pool/refinement.ts"
      via: "refinement endpoint calls generateRefinementQuestion"
      pattern: "generateRefinementQuestion"
---

<objective>
Build the AI-powered voice routing, idea refinement loop, and graduation workflow for the Idea Pool.

Purpose: Implements the three core AI-driven behaviors of Phase 6: (1) routing voice input to the correct project or Idea Pool, (2) iterative deep-questioning of ideas until they reach GSD-readiness, and (3) team consensus-based graduation of ideas to full projects.

Output: Voice routing analysis function, refinement loop with readiness scoring, graduation voting and execution logic, and corresponding API endpoints.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-voice-idea-pool/06-RESEARCH.md
@.planning/phases/06-voice-idea-pool/06-01-SUMMARY.md

# Key dependencies from Plan 01
@shared/types/idea.ts
@shared/types/ai.ts
@server/src/ai/generate.ts
@server/src/ai/config.ts
@server/src/events/reducers/idea.ts
@server/src/events/reducers/project.ts
@server/src/routes/ideas.ts
@server/src/routes/voice.ts
@server/src/events/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build voice routing analysis (AI determines target project or Idea Pool)</name>
  <files>
    server/src/voice/router-analysis.ts
    server/src/routes/voice.ts
  </files>
  <action>
    **Create `server/src/voice/router-analysis.ts`:**

    This module uses the existing `generateAiResponse` wrapper with a new `voice_routing` task type to analyze transcribed text and determine which existing project it belongs to (or if it's a new idea for the Idea Pool).

    ```typescript
    import { generateAiResponse } from '../ai/generate.js';
    import { getAllProjects } from '../events/reducers/project.ts';

    export interface RoutingSuggestion {
      type: 'existing_project' | 'idea_pool';
      projectId?: string;
      projectName?: string;
      confidence: number;       // 0-100
      reasoning: string;
    }

    export async function analyzeVoiceRouting(
      transcribedText: string,
      teamId: string,
      language: 'de' | 'en'
    ): Promise<RoutingSuggestion[]> {
      // 1. Fetch all non-archived projects for the team
      // 2. Build a project list summary: "- {id}: {name} - {description (first 100 chars)}"
      // 3. Call generateAiResponse with:
      //    - taskType: 'voice_routing'
      //    - projectId: teamId (for cost tracking, since no project yet)
      //    - systemPrompt: Instruct AI to analyze the transcribed text and determine
      //      if it belongs to an existing project or is a new idea. AI should return
      //      JSON array of up to 3 suggestions, each with:
      //      { type, projectId?, projectName?, confidence, reasoning }
      //      If no strong match, return [{ type: 'idea_pool', confidence: 80, reasoning: '...' }]
      //    - userPrompt: The transcribed text + project list
      //    - temperature: 0.2 (deterministic routing)
      // 4. Parse the AI response as JSON (wrap in try/catch, fall back to idea_pool if parse fails)
      // 5. Return the parsed suggestions array
    }
    ```

    The AI response should be structured JSON. Use a system prompt that enforces JSON output format. Include explicit instructions: "Respond ONLY with a JSON array. No markdown, no explanation."

    **Update `server/src/routes/voice.ts`:**

    Add a new endpoint below the existing `/transcribe`:

    ```
    POST /route
    ```

    Body: `{ text: string, teamId: string, language?: 'de' | 'en' }`

    This endpoint:
    1. Validates the request body with Zod (text required string min 1, teamId required string)
    2. Calls `analyzeVoiceRouting(text, teamId, language || 'en')`
    3. Returns `{ success: true, data: { suggestions: RoutingSuggestion[] } }`

    This is separate from `/transcribe` so the client can show the transcription first, then ask for routing in a second step (better UX -- user sees their words before the AI routes them).
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify exports:
    ```bash
    grep "export.*analyzeVoiceRouting" server/src/voice/router-analysis.ts
    grep "route" server/src/routes/voice.ts
    ```
  </verify>
  <done>
    analyzeVoiceRouting accepts transcribed text and returns up to 3 routing suggestions with confidence scores. POST /route endpoint validates input and returns suggestions. AI uses voice_routing task type with 0.2 temperature for deterministic routing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build AI refinement loop with readiness scoring</name>
  <files>
    server/src/idea-pool/refinement.ts
    server/src/routes/ideas.ts
  </files>
  <action>
    **Create `server/src/idea-pool/refinement.ts`:**

    Two main functions using the existing `generateAiResponse` wrapper:

    **`generateRefinementQuestion(idea: IdeaState, language: 'de' | 'en'): Promise<string>`**
    - Uses taskType `idea_refinement`
    - System prompt instructs AI to ask ONE focused question that fills the biggest gap in GSD-readiness
    - GSD-readiness requires: clear problem statement, target audience, feasibility indicators, effort/scope estimate
    - User prompt includes idea.refinedMarkdown and current refinementRounds
    - Returns the question text (just the string from result.text)

    **`assessReadiness(idea: IdeaState, language: 'de' | 'en'): Promise<{ score: number; missing: string[]; recommendation: string }>`**
    - Uses taskType `idea_readiness`
    - System prompt instructs AI to evaluate and return JSON with:
      - score: 0-100 (problem clarity 0-25, audience 0-25, feasibility 0-25, effort 0-25)
      - missing: array of strings describing gaps
      - recommendation: brief next step
    - Uses temperature 0.2 for consistent scoring
    - Parse AI response as JSON (with try/catch fallback returning score: 0 and generic missing items)

    **Update `server/src/routes/ideas.ts`:**

    Add two new endpoints:

    **`POST /:id/refine`** -- Trigger one refinement round:
    1. Get idea by ID, verify it exists and status is 'refining' (or 'capturing' for first round)
    2. Check refinementRounds < maxRefinementRounds (return 400 if exhausted)
    3. Call `generateRefinementQuestion(idea, language)`
    4. Emit `idea.refinement_question` event with the question text in data
    5. Return `{ success: true, data: { question } }`

    **`POST /:id/answer`** -- Submit answer to refinement question:
    Body: `{ answer: string, language?: 'de' | 'en' }`
    1. Get idea by ID, verify it exists and status is 'refining'
    2. Validate answer is non-empty string (Zod)
    3. Emit `idea.refinement_answer` event with the answer text in data
    4. Call `assessReadiness(updatedIdea, language)` to score the idea after the answer
    5. Emit `idea.readiness_assessed` event with score, missing, recommendation in data
    6. Return `{ success: true, data: { readinessScore, missing, recommendation } }`

    **`POST /:id/override-ready`** -- Manual override to mark idea as ready:
    Body: (none needed)
    1. Get idea, verify exists and status is 'refining'
    2. Emit `idea.readiness_assessed` event with score: 100, missing: [], recommendation: 'Manual override by user'
    3. Return updated idea state

    Wire `processEventForDocumentation` after each appendEvent (fire-and-forget pattern).
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify the refinement module exists:
    ```bash
    grep "export.*function" server/src/idea-pool/refinement.ts
    grep "refine\|answer\|override-ready" server/src/routes/ideas.ts
    ```
  </verify>
  <done>
    generateRefinementQuestion produces one targeted question per round. assessReadiness scores 0-100 with structured JSON output. Three new routes: POST /:id/refine, POST /:id/answer, POST /:id/override-ready. Refinement is bounded (maxRefinementRounds = 7) with manual override available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build graduation voting and idea-to-project promotion</name>
  <files>
    server/src/idea-pool/graduation.ts
    server/src/routes/ideas.ts
  </files>
  <action>
    **Create `server/src/idea-pool/graduation.ts`:**

    Three functions for the graduation workflow:

    **`proposeGraduation(ideaId: string, userId: string): Promise<IdeaState>`**
    1. Get idea by ID. Verify status is 'ready' (readinessScore >= READINESS_THRESHOLD or manually overridden)
    2. Emit `idea.graduation_proposed` event (aggregateType: 'idea_pool', aggregateId: ideaId)
    3. Return updated idea state

    **`voteOnGraduation(ideaId: string, userId: string, approve: boolean): Promise<IdeaState>`**
    1. Get idea by ID. Verify status is 'voting'
    2. Verify user hasn't already voted (check idea.votes[userId] !== undefined)
    3. Emit `idea.graduation_voted` event with data: { userId, approve }
    4. Return updated idea state

    **`executeGraduation(ideaId: string, userId: string): Promise<{ projectId: string; ideaId: string }>`**
    1. Get idea by ID. Verify status is 'voting'
    2. Get team by idea.teamId (use getTeamById or similar from team reducer)
    3. Verify all human team members have voted (filter out 'ai' role members)
    4. Verify all votes are true (unanimous approval for 2-person team)
    5. If not all voted or not all approved, throw descriptive error
    6. Generate projectId (randomUUID) and correlationId (randomUUID)
    7. Emit `project.created` event with:
       - aggregateType: 'project', aggregateId: projectId
       - data: { name: idea.title, description: idea.refinedMarkdown, teamId: idea.teamId, members: human member userIds }
    8. Emit `idea.graduated` event with:
       - aggregateType: 'idea_pool', aggregateId: ideaId
       - data: { projectId }
    9. Wire processEventForDocumentation for both events
    10. Return { projectId, ideaId }

    Import `getTeamById` from team reducer (`../events/reducers/team.ts` -- check existing export pattern) or use `reduceTeamState` + `readEvents`.

    **Update `server/src/routes/ideas.ts`:**

    Add three graduation endpoints:

    **`POST /:id/propose-graduation`**
    1. Validate idea exists, call proposeGraduation(id, req.session.userId)
    2. Return updated idea state

    **`POST /:id/vote`**
    Body: `{ approve: boolean }`
    1. Validate with Zod (approve must be boolean)
    2. Call voteOnGraduation(id, req.session.userId, approve)
    3. After voting, check if all team members have voted and all approved
    4. If so, auto-execute graduation by calling executeGraduation
    5. Return `{ success: true, data: { idea, graduated: boolean, projectId?: string } }`

    **`POST /:id/graduate`** (explicit graduation trigger, backup if auto-execute is not desired)
    1. Call executeGraduation(id, req.session.userId)
    2. Return `{ success: true, data: { projectId, ideaId } }`
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify graduation module:
    ```bash
    grep "export.*function" server/src/idea-pool/graduation.ts
    grep "propose-graduation\|vote\|graduate" server/src/routes/ideas.ts
    ```
  </verify>
  <done>
    Graduation flow: propose (status -> voting) -> vote (each member) -> execute (creates project from idea). Auto-graduation triggers when last team member votes approve. For a 2-person team, unanimous approval required. The graduated idea links to its new project via projectId.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `server/src/voice/router-analysis.ts` exports analyzeVoiceRouting
3. `server/src/idea-pool/refinement.ts` exports generateRefinementQuestion, assessReadiness
4. `server/src/idea-pool/graduation.ts` exports proposeGraduation, voteOnGraduation, executeGraduation
5. Ideas routes include all endpoints: GET /, GET /:id, POST /, POST /:id/archive, POST /:id/refine, POST /:id/answer, POST /:id/override-ready, POST /:id/propose-graduation, POST /:id/vote, POST /:id/graduate
6. Voice routes include: POST /transcribe, POST /route
7. AI task types voice_routing, idea_refinement, idea_readiness are used correctly
</verification>

<success_criteria>
Voice routing suggests matching projects with confidence scores. Refinement loop generates targeted questions and scores readiness. Graduation requires unanimous team approval and creates a real project from idea content.
</success_criteria>

<output>
After completion, create `.planning/phases/06-voice-idea-pool/06-02-SUMMARY.md`
</output>
