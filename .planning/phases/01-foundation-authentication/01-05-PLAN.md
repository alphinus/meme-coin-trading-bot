---
phase: 01-foundation-authentication
plan: 05
type: execute
wave: 3
depends_on: ["01-01"]
files_modified:
  - server/src/fs/paths.ts
  - server/src/fs/watcher.ts
  - server/src/fs/git.ts
  - server/src/fs/memory.ts
  - server/src/routes/memory.ts
  - data/memory/.gitkeep
autonomous: true

must_haves:
  truths:
    - "Per-project folders are auto-created in the memory directory"
    - "Per-member Markdown files exist within each project folder"
    - "Memory files are human-editable and the app detects external changes"
    - "All memory file changes are automatically committed to Git with debounced batching"
    - "Filesystem allowlist prevents writes outside designated paths"
  artifacts:
    - path: "server/src/fs/paths.ts"
      provides: "Path resolution and allowlist enforcement"
      exports: ["resolvePath", "isPathAllowed", "getAllowedPaths"]
    - path: "server/src/fs/watcher.ts"
      provides: "Chokidar file watcher for memory directory"
      exports: ["startMemoryWatcher", "stopMemoryWatcher"]
    - path: "server/src/fs/git.ts"
      provides: "Git operations with debounced commit queue"
      exports: ["initMemoryRepo", "scheduleCommit", "getFileHistory"]
    - path: "server/src/fs/memory.ts"
      provides: "Memory file CRUD operations"
      exports: ["createProjectMemory", "readMemoryFile", "writeMemoryFile", "listProjectMemoryFiles"]
    - path: "server/src/routes/memory.ts"
      provides: "Memory file API endpoints"
      exports: ["memoryRouter"]
  key_links:
    - from: "server/src/fs/memory.ts"
      to: "server/src/fs/paths.ts"
      via: "validates all paths through allowlist"
      pattern: "isPathAllowed"
    - from: "server/src/fs/watcher.ts"
      to: "server/src/fs/git.ts"
      via: "triggers git commit on file changes"
      pattern: "scheduleCommit"
    - from: "server/src/fs/watcher.ts"
      to: "server/src/events/store.ts"
      via: "emits memory.file_changed event on external edits"
      pattern: "appendEvent.*memory"
    - from: "server/src/routes/memory.ts"
      to: "server/src/fs/memory.ts"
      via: "uses memory CRUD functions"
      pattern: "import.*from.*fs/memory"
---

<objective>
Implement the local filesystem memory system with per-project folders, per-member Markdown files, Git-backed versioning, file watching for external edits, and path security via allowlist.

Purpose: The filesystem IS the database for human-readable content. Per-project memory with per-member Markdown files provides the team's persistent, editable knowledge base. Git versioning ensures nothing is ever lost. The allowlist protects system paths from autonomous writes (INFRA-03, INFRA-04, INFRA-05).
Output: Working memory system with file CRUD, auto Git commits, external change detection, and path security.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Filesystem security (allowlist) and memory file CRUD</name>
  <files>
    server/src/fs/paths.ts
    server/src/fs/memory.ts
    server/src/routes/memory.ts
  </files>
  <action>
    Install filesystem dependencies: `npm install chokidar simple-git` in the server package.

    server/src/fs/paths.ts (Whitelist approach per research recommendation):
    - DATA_DIR from env (default './data')
    - MEMORY_DIR = join(DATA_DIR, 'memory')
    - Default allowed paths: [DATA_DIR, MEMORY_DIR, join(os.tmpdir(), 'eluma')]
    - loadAllowedPaths(): reads from `{DATA_DIR}/system/allowed-paths.json` if exists, falls back to defaults
    - isPathAllowed(targetPath: string): boolean -- resolves the path to absolute, checks if it starts with any allowed path. Uses path.resolve() to prevent traversal attacks (../../etc). Returns false for any path outside allowed directories.
    - resolvePath(...segments: string[]): string -- joins and resolves path segments, throws if result is not within allowed paths
    - CRITICAL: All filesystem write operations in the app MUST go through resolvePath(). Direct fs.writeFile with user-provided paths is forbidden.
    - getMemoryDir(): string -- returns MEMORY_DIR
    - ensureDir(dirPath: string): void -- creates directory recursively, only if path is allowed

    server/src/fs/memory.ts:
    - createProjectMemory(projectId: string, projectName: string, memberNames: string[]): void
      - Creates directory: `{MEMORY_DIR}/{projectId}/`
      - Creates initial Markdown files: `{memberName}.md` for each member
      - Each file starts with frontmatter: `---\nproject: {projectName}\nmember: {memberName}\ncreated: {ISO date}\n---\n\n# {projectName} - {memberName}\n\n`
      - All paths validated through resolvePath()
    - readMemoryFile(projectId: string, fileName: string): string | null
      - Reads Markdown file content. Returns null if not found.
    - writeMemoryFile(projectId: string, fileName: string, content: string): void
      - Writes content to memory file. Path validated. Emits "memory.file_updated" event.
    - listProjectMemoryFiles(projectId: string): Array<{name, size, lastModified}>
      - Lists all .md files in a project memory folder
    - deleteMemoryFile(projectId: string, fileName: string): void
      - Soft delete: renames to `.{name}.deleted.{timestamp}` rather than removing
    - getMemoryFileHistory(projectId: string, fileName: string): git log entries (delegates to git.ts)

    server/src/routes/memory.ts:
    - GET /api/memory/:projectId -- list memory files for a project
    - GET /api/memory/:projectId/:fileName -- read a specific memory file
    - PUT /api/memory/:projectId/:fileName -- update a memory file (body: { content })
    - POST /api/memory/:projectId -- create a new memory file (body: { fileName, content? })
    - DELETE /api/memory/:projectId/:fileName -- soft delete a memory file
    - GET /api/memory/:projectId/:fileName/history -- get Git history for a file
    - All routes require auth. All paths validated through paths.ts allowlist.
    - Each mutation emits an event to the event store.

    Mount memoryRouter on /api/memory in app.ts.
  </action>
  <verify>
    1. `npx tsc --noEmit` compiles without errors
    2. Create a project memory folder via API:
       `curl -X POST /api/memory/test-project -d '{"fileName":"elvis.md","content":"# Test"}' -b cookies.txt`
    3. Verify file exists: `ls data/memory/test-project/elvis.md`
    4. Read file via API: `curl /api/memory/test-project/elvis.md -b cookies.txt` returns content
    5. Update file via API: `curl -X PUT /api/memory/test-project/elvis.md -d '{"content":"# Updated"}' -b cookies.txt`
    6. Verify path traversal blocked: `curl -X POST /api/memory/../../etc -d '{"fileName":"passwd"}' -b cookies.txt` returns 403
    7. Verify allowlist: attempting to write outside data/ directory fails
  </verify>
  <done>
    Memory file CRUD works through the API. Per-project folders with per-member Markdown files are created correctly. Allowlist prevents writes outside designated paths. All mutations emit events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Git-backed versioning and file watcher for external edits</name>
  <files>
    server/src/fs/git.ts
    server/src/fs/watcher.ts
    server/src/app.ts
  </files>
  <action>
    server/src/fs/git.ts:
    - Uses simple-git library
    - MEMORY_DIR from paths.ts
    - initMemoryRepo(): initializes Git repo in MEMORY_DIR if not already a Git repo. Sets git config user.name "Eluma" and user.email "system@eluma.local" for auto-commits.
    - Commit queue pattern (per research -- prevents race conditions):
      - Private state: commitInProgress (boolean), pendingFiles (Set<string>), commitTimeout (NodeJS.Timeout | null)
      - scheduleCommit(filePath: string): adds file to pendingFiles, debounces with 5-second window (per research recommendation). Clears and resets timer on each call.
      - performCommit(): if commitInProgress or no pending files, return. Sets commitInProgress=true. Takes snapshot of pendingFiles, clears set. Stages files with git.add(), commits with auto-generated message: "auto: update {fileNames} at {timestamp}". On error: re-adds files to pending, logs error. Finally: commitInProgress=false, if more pending files accumulated during commit, schedule another.
    - getFileHistory(filePath: string, limit?: number): returns git log entries for a specific file (date, message, hash)
    - getFileDiff(filePath: string, commitHash: string): returns diff for a specific commit

    server/src/fs/watcher.ts:
    - Uses chokidar library
    - startMemoryWatcher(): creates chokidar watcher on MEMORY_DIR with:
      - ignoreInitial: true (per research pitfall #4)
      - ignored: /(^|[\/\\])\./ (ignore dotfiles including .git)
      - persistent: true
      - awaitWriteFinish: { stabilityThreshold: 500, pollInterval: 100 }
    - On 'change' event for .md files:
      - Emit "memory.file_changed" event to event store (captures who/what changed -- for external edits, userId is "system" since we can't know who edited externally)
      - Call scheduleCommit(filePath) to queue Git commit
    - On 'add' event for .md files:
      - Emit "memory.file_created" event
      - Call scheduleCommit(filePath)
    - On 'unlink' event for .md files:
      - Emit "memory.file_deleted" event
      - Call scheduleCommit(filePath)
    - stopMemoryWatcher(): closes the watcher (for clean shutdown)

    Update server/src/app.ts:
    - On startup: call initMemoryRepo() and startMemoryWatcher()
    - On SIGTERM/SIGINT: call stopMemoryWatcher() for clean shutdown

    Update server/src/fs/memory.ts:
    - After writeMemoryFile, call scheduleCommit (file watcher will also catch it, but direct API writes should trigger commit too)
    - The watcher and direct writes may both trigger -- the commit queue deduplicates via the Set

    IMPORTANT: The watcher detects EXTERNAL changes (user editing files in VS Code, vim, etc.). This is a locked user decision: "Memory files are human-editable -- users can open and modify Markdown files directly in any editor. App watches for external changes."
  </action>
  <verify>
    1. `npx tsc --noEmit` compiles without errors
    2. Start the server. Verify Git repo initialized in data/memory/ (`ls data/memory/.git`)
    3. Create a memory file via API. Wait 6 seconds. Check `git -C data/memory log` shows an auto-commit
    4. Edit the file externally: `echo "external edit" >> data/memory/test-project/elvis.md`
    5. Wait 6 seconds. Check `git -C data/memory log` shows a new commit for the external change
    6. Check event store: `cat data/events/memory.jsonl` shows both the API write event and the external change event
    7. Get file history via API: `curl /api/memory/test-project/elvis.md/history -b cookies.txt` returns git log entries
    8. Rapid edits test: make 5 quick edits within 3 seconds, verify only 1 or 2 commits are created (debouncing works)
  </verify>
  <done>
    Git repo is initialized in the memory directory. All file changes (API and external) are auto-committed with 5-second debounce. External file edits are detected by chokidar and emit events. File history is queryable. Commit queue prevents race conditions.
  </done>
</task>

</tasks>

<verification>
- Memory file CRUD works via API
- Per-project folders with per-member Markdown files
- Allowlist blocks writes outside designated paths
- Git repo tracks all changes with debounced commits
- External file edits are detected and committed
- File history is queryable
</verification>

<success_criteria>
1. Creating a project memory produces per-member .md files in the correct directory
2. Path traversal attacks are blocked (../../ etc returns 403)
3. Git auto-commits happen within 5 seconds of file changes
4. External file edits (via editor) trigger watcher events and Git commits
5. File history API returns Git log entries for each memory file
6. Rapid edits are debounced into fewer commits
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-05-SUMMARY.md`
</output>
