---
phase: 01-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - server/package.json
  - server/tsconfig.json
  - server/src/index.ts
  - server/src/app.ts
  - client/package.json
  - client/tsconfig.json
  - client/vite.config.ts
  - client/index.html
  - client/src/main.tsx
  - client/src/App.tsx
  - client/src/api/client.ts
  - shared/types/events.ts
  - shared/types/models.ts
  - shared/types/api.ts
  - server/src/events/store.ts
  - server/src/events/types.ts
  - server/src/events/projector.ts
  - server/src/events/feed.ts
  - server/src/routes/events.ts
  - server/src/middleware/validate.ts
  - .env.example
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Express server starts and serves the React SPA on localhost:3000"
    - "Event store can append events to JSONL files and read them back"
    - "Events are queryable by aggregate type and aggregate ID"
    - "Activity feed endpoint returns events sorted by timestamp descending"
    - "TypeScript compiles without errors across server, client, and shared packages"
  artifacts:
    - path: "shared/types/events.ts"
      provides: "DomainEvent interface and event type constants"
      contains: "DomainEvent"
    - path: "shared/types/models.ts"
      provides: "User, Team, Project domain model types"
      contains: "interface User"
    - path: "server/src/events/store.ts"
      provides: "JSONL event store with append and read operations"
      exports: ["appendEvent", "readEvents", "readAllEvents"]
    - path: "server/src/events/projector.ts"
      provides: "Event replay to derive current state"
      exports: ["projectState", "cacheProjection"]
    - path: "server/src/app.ts"
      provides: "Express app with middleware and route mounting"
      contains: "express"
    - path: "client/src/App.tsx"
      provides: "React root component with router shell"
      contains: "BrowserRouter"
  key_links:
    - from: "server/src/index.ts"
      to: "server/src/app.ts"
      via: "imports app, starts ViteExpress"
      pattern: "ViteExpress\\.listen"
    - from: "server/src/routes/events.ts"
      to: "server/src/events/store.ts"
      via: "imports event store functions"
      pattern: "import.*from.*events/store"
    - from: "server/src/events/store.ts"
      to: "shared/types/events.ts"
      via: "uses DomainEvent type"
      pattern: "import.*DomainEvent"
    - from: "client/src/api/client.ts"
      to: "/api/*"
      via: "fetch wrapper targeting Express API"
      pattern: "fetch.*api/"
---

<objective>
Scaffold the Eluma monorepo (server + client + shared) and implement the filesystem-based event store core.

Purpose: Establish the project foundation that every subsequent plan depends on. The event store is the architectural backbone -- every state change in the system flows through it.
Output: Working Express+Vite+React monorepo with JSONL event store, shared TypeScript types, and a health/events API.
</objective>

<execution_context>
@/Users/developer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/developer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold monorepo with Express + Vite + React + shared types</name>
  <files>
    package.json
    tsconfig.json
    .gitignore
    .env.example
    server/package.json
    server/tsconfig.json
    server/src/index.ts
    server/src/app.ts
    server/src/middleware/validate.ts
    client/package.json
    client/tsconfig.json
    client/vite.config.ts
    client/index.html
    client/src/main.tsx
    client/src/App.tsx
    client/src/api/client.ts
    shared/types/events.ts
    shared/types/models.ts
    shared/types/api.ts
  </files>
  <action>
    Create the Eluma project directory at `/Users/developer/eluma/`.

    Initialize a TypeScript monorepo using npm workspaces with three packages: server, client, shared.

    Root package.json:
    - name: "eluma"
    - workspaces: ["server", "client", "shared"]
    - scripts: "dev" runs server and client concurrently via `concurrently`
    - scripts: "build" builds shared, then server, then client

    Root tsconfig.json:
    - compilerOptions: target ES2022, module NodeNext, moduleResolution NodeNext, strict true, esModuleInterop true, skipLibCheck true
    - references to server, client, shared

    shared/types/events.ts:
    - DomainEvent interface with fields: id (string), type (string), aggregateType (string), aggregateId (string), timestamp (string ISO 8601), userId (string), correlationId (string), version (number), data (Record<string, unknown>)
    - EventType string literal union covering initial event types: "user.created", "user.updated", "team.created", "team.member_added", "team.member_removed", "project.created", "project.updated", "system.capability_discovered", "system.config_updated"

    shared/types/models.ts:
    - User interface: id, username, displayName, email, passwordHash (optional), passkeys (array of PasskeyCredential), language ("de" | "en"), createdAt, updatedAt
    - PasskeyCredential interface: credentialId (string/Uint8Array), publicKey (string/Uint8Array), counter (number), transports (string[])
    - Team interface: id, name, members (string[] of user IDs), createdAt
    - Project interface: id, name, description, teamId, members (string[]), createdAt, updatedAt
    - SystemCapability interface: name, category, installed, path?, version?

    shared/types/api.ts:
    - ApiResponse<T> type: { success: true, data: T } | { success: false, error: string }
    - ApiError type with status code and message

    server/src/app.ts:
    - Create Express app with: express.json(), helmet (with CSP disabled -- needed for WebAuthn), compression, cors (dev only)
    - Mount placeholder route groups: /api/auth, /api/events, /api/teams, /api/projects, /api/system, /api/memory, /api/github
    - Add a GET /api/health endpoint returning { status: "ok", timestamp: ISO string }
    - Error handling middleware at the end

    server/src/index.ts:
    - Import app from app.ts
    - Use ViteExpress.listen(app, PORT) where PORT defaults to 3000 from env
    - Log startup message with URL

    server/src/middleware/validate.ts:
    - Generic Zod validation middleware factory: takes a Zod schema, returns Express middleware that validates req.body and returns 400 with error details on failure

    client/vite.config.ts:
    - React plugin
    - Server proxy: /api -> http://localhost:3000 (for dev mode)

    client/src/App.tsx:
    - React Router with BrowserRouter
    - Placeholder routes: / (Dashboard), /login (Login), /setup (Setup), /settings (Settings)
    - Each route renders a simple placeholder div with the page name

    client/src/api/client.ts:
    - Typed fetch wrapper: async function apiCall<T>(method, url, body?) -> ApiResponse<T>
    - Handles JSON serialization, error wrapping, includes credentials: 'same-origin'

    .gitignore: node_modules, dist, .env, data/sessions, *.log, .DS_Store
    .env.example: PORT=3000, NODE_ENV=development, SESSION_SECRET=change-me, DATA_DIR=./data, RP_ID=localhost, ORIGIN=http://localhost:3000

    Install all dependencies:
    - Server: express, express-session, session-file-store, helmet, compression, cors, uuid, zod, vite-express
    - Client: react, react-dom, react-router-dom
    - Shared: (no runtime deps, just types)
    - Dev: typescript, @types/node, @types/express, @types/express-session, @types/cors, @types/compression, @types/uuid, @vitejs/plugin-react, vite, concurrently, tsx

    Do NOT install auth libraries yet (Plan 02). Do NOT install i18n libraries yet (Plan 03). Do NOT install chokidar or simple-git yet (Plan 05).
  </action>
  <verify>
    1. `cd /Users/developer/eluma && npm install` completes without errors
    2. `npx tsc --noEmit` in root compiles all three packages without errors
    3. `npm run dev` starts the server and `curl http://localhost:3000/api/health` returns `{"status":"ok","timestamp":"..."}`
    4. Opening `http://localhost:3000` in a browser shows the React app placeholder
  </verify>
  <done>
    Monorepo builds and runs. Express serves the React SPA. Health endpoint responds. All TypeScript types compile. Shared types are importable from both server and client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement filesystem-based JSONL event store with projector and feed</name>
  <files>
    server/src/events/store.ts
    server/src/events/types.ts
    server/src/events/projector.ts
    server/src/events/feed.ts
    server/src/routes/events.ts
  </files>
  <action>
    Build the event store core that every feature in the app will use for state changes.

    Per user decision: pure filesystem storage, no database. Events are append-only JSONL files. Per research: one JSONL file per aggregate type.

    server/src/events/types.ts:
    - Re-export DomainEvent from shared/types/events
    - Define CreateEventInput type (DomainEvent without id and timestamp -- those are auto-generated)
    - Define EventFilter type: { aggregateType?, aggregateId?, userId?, type?, since?, limit? }

    server/src/events/store.ts:
    - DATA_DIR from env with fallback to ./data
    - EVENTS_DIR = join(DATA_DIR, 'events')
    - appendEvent(input: CreateEventInput): DomainEvent -- generates UUID id and ISO timestamp, appends JSON line to `{aggregateType}.jsonl`, ensures directory exists with mkdirSync recursive. Use appendFileSync for atomicity (events are small, well under 4KB PIPE_BUF).
    - readEvents(aggregateType: string, aggregateId?: string): DomainEvent[] -- reads JSONL file line by line, parses each line in try/catch (skip corrupted lines with console.warn), filters by aggregateId if provided.
    - readAllEvents(filter?: EventFilter): DomainEvent[] -- reads ALL .jsonl files in events dir, merges, sorts by timestamp descending, applies filter (since, limit, userId, type). This powers the activity feed.
    - validateLastLine(filePath: string): void -- called on startup, checks if last line of each JSONL file is valid JSON. If not, truncates the partial line (crash recovery per research pitfall #3).
    - initEventStore(): void -- creates events directory if missing, validates all existing JSONL files

    server/src/events/projector.ts:
    - projectState<T>(aggregateType: string, aggregateId: string, reducer: (state: Partial<T>, event: DomainEvent) => Partial<T>): T | null -- generic projector that replays events through a reducer function
    - cacheProjection(aggregateType: string, aggregateId: string, state: unknown): void -- writes projected state to `data/{aggregateType}/{aggregateId}.json` for fast reads
    - readCachedProjection<T>(aggregateType: string, aggregateId: string): T | null -- reads cached state if exists

    server/src/events/feed.ts:
    - getActivityFeed(options: { limit?: number, since?: string, teamId?: string }): DomainEvent[] -- wrapper around readAllEvents optimized for the UI activity feed. Returns latest N events (default 50). Does NOT include system-internal events (type starting with "system.internal.").

    server/src/routes/events.ts:
    - GET /api/events -- returns activity feed (latest 50 events). Query params: limit, since (ISO timestamp). Requires auth (but auth middleware not added yet -- add a TODO comment and skip auth check for now).
    - GET /api/events/:aggregateType -- returns events for an aggregate type. Query param: aggregateId.
    - Both endpoints return ApiResponse wrapper format.

    Call initEventStore() from server/src/app.ts on startup.

    IMPORTANT: Use async fs operations (fs/promises) for read operations in route handlers. Use sync appendFileSync ONLY for the event append (atomicity requirement). This follows the research anti-pattern guidance.
  </action>
  <verify>
    1. `npx tsc --noEmit` compiles without errors
    2. Start the server, then:
       - `curl -X POST http://localhost:3000/api/events` (should fail gracefully -- POST not yet implemented, but GET should work)
       - Manually create a test event by calling appendEvent from a test script or adding a seed route
       - `curl http://localhost:3000/api/events` returns the seeded events in the activity feed format
    3. Verify JSONL file exists at `data/events/{aggregateType}.jsonl` and contains valid JSON lines
    4. Verify corrupted last line recovery: append a partial line to a JSONL file, restart server, confirm the partial line is cleaned up
  </verify>
  <done>
    Event store appends events atomically to JSONL files. Events are readable by aggregate type and ID. Activity feed returns events sorted by timestamp. Corrupted JSONL recovery works on startup. All routes return properly typed ApiResponse format.
  </done>
</task>

</tasks>

<verification>
- Express + Vite + React monorepo starts with `npm run dev`
- Health endpoint responds at /api/health
- Event store creates JSONL files in data/events/
- Events API returns activity feed data
- TypeScript compiles cleanly across all packages
- Shared types are used consistently between server and client
</verification>

<success_criteria>
1. `npm run dev` starts the full stack (server + client) without errors
2. GET /api/health returns 200 with status "ok"
3. Event store appendEvent creates valid JSONL entries
4. GET /api/events returns events in descending timestamp order
5. All TypeScript files compile without errors (`npx tsc --noEmit`)
6. React app renders in browser at localhost:3000
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-01-SUMMARY.md`
</output>
